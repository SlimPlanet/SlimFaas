{"pageProps":{"contentHtml":"<html><head></head><body><h1>SlimFaas Autoscaling Guide</h1>\n<blockquote>\n<p>End-to-end autoscaling for SlimFaas functions:\n<strong>HTTP activity &amp; schedules for <code>0 ‚Üí N</code> + Prometheus / PromQL AutoScaler for <code>N ‚Üí M</code></strong></p>\n</blockquote>\n<hr>\n<h2>Table of contents</h2>\n<ol>\n<li><a href=\"#overview\">Overview</a></li>\n<li><a href=\"#core-concepts\">Core concepts</a></li>\n<li><a href=\"#autoscaling-architecture\">Autoscaling architecture</a></li>\n<li><a href=\"#configuring-0--n-scale-http-history--schedule\">Configuring <code>0 ‚Üí N</code> scale (HTTP history + schedule)</a></li>\n<li><a href=\"#configuring-n--m-scale-prometheus-autoscaler\">Configuring <code>N ‚Üí M</code> scale (Prometheus AutoScaler)</a></li>\n<li><a href=\"#promql-support--current-limitations\">PromQL support &amp; current limitations</a></li>\n<li><a href=\"#metrics-scraping-internals\">Metrics scraping internals</a></li>\n<li><a href=\"#debug-http-endpoints\">Debug HTTP endpoints</a></li>\n<li><a href=\"#decision-algorithm-details\">Decision algorithm details</a></li>\n<li><a href=\"#configuration-examples\">Configuration examples</a></li>\n<li><a href=\"#best-practices\">Best practices</a></li>\n<li><a href=\"#observability--debugging\">Observability &amp; debugging</a></li>\n<li><a href=\"#faq\">FAQ</a></li>\n</ol>\n<hr>\n<h2>Overview</h2>\n<p>SlimFaas combines <strong>two complementary autoscaling systems</strong>:</p>\n<ol>\n<li>\n<p><strong><code>0 ‚Üí N</code> scaling (wake-up from zero)</strong>\nDriven by:</p>\n<ul>\n<li>HTTP call history (in-memory + database),</li>\n<li>optional <strong>schedule configuration</strong> (wake-up times, scale-down timeouts),</li>\n<li><strong>function dependencies</strong> (<code>DependsOn</code>).</li>\n</ul>\n<p>üëâ This system is the <strong>only one allowed to bring a function from <code>0</code> to <code>&gt; 0</code> replicas</strong>.</p>\n</li>\n<li>\n<p><strong><code>N ‚Üí M</code> scaling (Prometheus AutoScaler)</strong>\nDriven by:</p>\n<ul>\n<li>a Prometheus metrics scraping worker,</li>\n<li>a small PromQL evaluator,</li>\n<li>an <code>AutoScaler</code> that computes the desired number of replicas based on metrics.</li>\n</ul>\n<p>üëâ This system is used <strong>only when the function already has at least one pod</strong> (<code>replicas &gt; 0</code>).</p>\n</li>\n</ol>\n<p>Both systems are orchestrated by:</p>\n<ul>\n<li><code>ReplicasService.CheckScaleAsync(namespace)</code></li>\n<li><code>ScaleReplicasWorker</code>, a background worker that calls <code>CheckScaleAsync</code> periodically on the master node.</li>\n</ul>\n<hr>\n<h2>Core concepts</h2>\n<p>In SlimFaas, each function is represented by a Kubernetes <code>Deployment</code> and a set of <strong>annotations</strong> that drive autoscaling.</p>\n<h3>Key properties (conceptual)</h3>\n<p>For each function (deployment):</p>\n<ul>\n<li>\n<p><strong>Current replicas</strong>\nThe current number of pods, as seen by SlimFaas.</p>\n</li>\n<li>\n<p><strong><code>ReplicasMin</code></strong>\nMinimal number of pods allowed after scale-down. This can be <code>0</code> if you want <strong>scale-to-zero</strong>, or a positive value if you want to avoid full cold starts.</p>\n</li>\n<li>\n<p><strong><code>ReplicasAtStart</code></strong>\nNumber of pods to start when waking up a function from <code>0</code> (or from below minimum) via the <code>0 ‚Üí N</code> system.</p>\n</li>\n<li>\n<p><strong><code>TimeoutSecondBeforeSetReplicasMin</code></strong>\nInactivity duration (based on HTTP history and schedule) before SlimFaas scales down the function to <code>ReplicasMin</code>.</p>\n</li>\n<li>\n<p><strong><code>DependsOn</code></strong>\nList of other functions that this function depends on. SlimFaas can ensure dependencies are ready before waking up a function.</p>\n</li>\n<li>\n<p><strong><code>Schedule</code></strong>\nTime-based configuration for:</p>\n<ul>\n<li><strong>wake-up times</strong> (treated as synthetic HTTP activity),</li>\n<li><strong>time-dependent scale-down timeouts</strong>.</li>\n</ul>\n</li>\n<li>\n<p><strong><code>Scale</code></strong>\nMetrics-based autoscaling configuration, powered by Prometheus &amp; PromQL, used for <code>N ‚Üí M</code> scaling.</p>\n</li>\n</ul>\n<h3>How this is exposed in Kubernetes</h3>\n<p>Many of these properties are configured via <strong>annotations</strong> on your function <code>Deployment</code>, for example:</p>\n<pre><code class=\"language-yaml hljs\"><span class=\"hljs-params\">apiVersion:</span> apps<span class=\"hljs-symbol\">/v1</span>\n<span class=\"hljs-params\">kind:</span> Deployment\n<span class=\"hljs-params\">metadata:</span>\n  <span class=\"hljs-params\">name:</span> fibonacci\n  <span class=\"hljs-params\">namespace:</span> default\n  <span class=\"hljs-params\">annotations:</span>\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">ReplicasMin:</span> <span class=\"hljs-string\">\"0\"</span>\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">ReplicasAtStart:</span> <span class=\"hljs-string\">\"1\"</span>\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">TimeoutSecondBeforeSetReplicasMin:</span> <span class=\"hljs-string\">\"300\"</span>\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">DependsOn:</span> '[<span class=\"hljs-string\">\"another-func-a\"</span>,<span class=\"hljs-string\">\"another-func-b\"</span>]'\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">Schedule:</span> <span class=\"hljs-operator\">&gt;</span>\n      {\n        <span class=\"hljs-string\">\"TimeZoneID\"</span>: <span class=\"hljs-string\">\"Europe/Paris\"</span>,\n        <span class=\"hljs-string\">\"Default\"</span>: {\n          <span class=\"hljs-string\">\"WakeUp\"</span>: [ <span class=\"hljs-string\">\"08:00\"</span>, <span class=\"hljs-string\">\"13:30\"</span> ],\n          <span class=\"hljs-string\">\"ScaleDownTimeout\"</span>: [\n            { <span class=\"hljs-string\">\"Time\"</span>: <span class=\"hljs-string\">\"08:00\"</span>, <span class=\"hljs-string\">\"Value\"</span>: <span class=\"hljs-number\">1800</span> },\n            { <span class=\"hljs-string\">\"Time\"</span>: <span class=\"hljs-string\">\"19:00\"</span>, <span class=\"hljs-string\">\"Value\"</span>: <span class=\"hljs-number\">300</span> }\n          ]\n        }\n      }\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">Scale:</span> <span class=\"hljs-operator\">&gt;</span>\n      {\n        <span class=\"hljs-string\">\"ReplicaMax\"</span>: <span class=\"hljs-number\">10</span>,\n        <span class=\"hljs-string\">\"Triggers\"</span>: [],\n        <span class=\"hljs-string\">\"Behavior\"</span>: {}\n      }\n<span class=\"hljs-params\">spec:</span>\n  <span class=\"hljs-params\">replicas:</span> <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-comment\"># ...</span>\n</code></pre>\n<blockquote>\n<p>Note: when the <code>SlimFaas/Scale</code> annotation is not present (or is invalid), the Prometheus-based AutoScaler is simply disabled for that function.</p>\n</blockquote>\n<hr>\n<h2>Autoscaling architecture</h2>\n<h3>High-level diagram</h3>\n<pre><code class=\"language-mermaid hljs\">flowchart LR\n    subgraph HTTP_history[<span class=\"hljs-string\">\"HTTP history &amp; Schedule (0‚ÜíN)\"</span>]\n        H[History HTTP (<span class=\"hljs-built_in\">in</span>-memory + DB)] --&gt; R\n        S[Schedule config] --&gt; R\n        D[DependsOn] --&gt; R\n    <span class=\"hljs-keyword\">end</span>\n\n    subgraph Prometheus[<span class=\"hljs-string\">\"Prometheus AutoScaler (N‚ÜíM)\"</span>]\n        MSW[MetricsScrapingWorker] --&gt; MS[Metrics store]\n        MS --&gt; PQ[PromQL evaluator]\n        PQ --&gt; AS[AutoScaler]\n        AS --&gt; ASS[AutoScalerStore]\n    <span class=\"hljs-keyword\">end</span>\n\n    subgraph Core[<span class=\"hljs-string\">\"Scaling orchestration\"</span>]\n        R[ReplicasService.CheckScaleAsync]\n        SW[ScaleReplicasWorker]\n    <span class=\"hljs-keyword\">end</span>\n\n    SW --&gt; R\n    R --&gt;|<span class=\"hljs-type\">scale</span> <span class=\"hljs-number\">0</span>‚ÜíN / N‚Üí<span class=\"hljs-number\">0</span>| <span class=\"hljs-type\">K8S</span>[(Kubernetes API)]\n    R --&gt;|<span class=\"hljs-type\">desiredReplicas</span> N‚ÜíM| <span class=\"hljs-type\">K8S</span>\n</code></pre>\n<ul>\n<li><code>ScaleReplicasWorker</code> periodically calls <code>CheckScaleAsync</code> if the node is the master.</li>\n<li><code>ReplicasService.CheckScaleAsync</code>:\n<ol>\n<li>Computes a <strong>desired replica count</strong> using the <strong>HTTP/schedule based system</strong> (<code>0 ‚Üí N</code> / <code>N ‚Üí 0</code>).</li>\n<li>If the function already has <code>replicas &gt; 0</code> and a <code>SlimFaas/Scale</code> annotation, it invokes the <strong>Prometheus AutoScaler</strong> to adjust <code>N ‚Üí M</code>.</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2>Configuring <code>0 ‚Üí N</code> scale (HTTP history + schedule)</h2>\n<p>The <code>0 ‚Üí N</code> system is responsible for:</p>\n<ul>\n<li><strong>Scaling down</strong> to <code>ReplicasMin</code> after inactivity,</li>\n<li><strong>Waking up</strong> functions to <code>ReplicasAtStart</code> based on:\n<ul>\n<li>HTTP activity,</li>\n<li>schedule,</li>\n<li>dependencies.</li>\n</ul>\n</li>\n</ul>\n<h3>Inactivity timeout ‚Üí scale down to <code>ReplicasMin</code></h3>\n<p>SlimFaas measures the time since the last HTTP activity (or synthetic activity from schedule/dependencies).</p>\n<p>Key annotations:</p>\n<pre><code class=\"language-yaml hljs\"><span class=\"hljs-params\">metadata:</span>\n  <span class=\"hljs-params\">annotations:</span>\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">ReplicasMin:</span> <span class=\"hljs-string\">\"0\"</span>                         <span class=\"hljs-comment\"># minimum replicas after scale-down (can be 0)</span>\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">ReplicasAtStart:</span> <span class=\"hljs-string\">\"1\"</span>                     <span class=\"hljs-comment\"># replicas after wake-up from zero</span>\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">TimeoutSecondBeforeSetReplicasMin:</span> <span class=\"hljs-string\">\"300\"</span> <span class=\"hljs-comment\"># seconds of inactivity before scale-down</span>\n</code></pre>\n<p>Behavior (simplified):</p>\n<ul>\n<li>\n<p>SlimFaas computes a last activity timestamp for each function:</p>\n<ul>\n<li>from HTTP history,</li>\n<li>plus schedule wake-up events,</li>\n<li>plus the dependencies‚Äô activity if relevant.</li>\n</ul>\n</li>\n<li>\n<p>If:</p>\n<pre><code class=\"language-text hljs\">lastActivity + TimeoutSecondBeforeSetReplicasMin &lt; <span class=\"hljs-built_in\">now</span>\n</code></pre>\n<p>then SlimFaas scales the function to <strong><code>ReplicasMin</code></strong>.</p>\n</li>\n</ul>\n<p>If <code>ReplicasMin</code> is <code>\"0\"</code>, this gives you <strong>scale-to-zero</strong>.</p>\n<h3>Wake-up <code>0 ‚Üí N</code> (from zero or below minimum)</h3>\n<p>There are two main situations where SlimFaas wakes a function up:</p>\n<ol>\n<li>\n<p><strong>From <code>0</code> to <code>ReplicasAtStart</code></strong>:</p>\n<ul>\n<li>The function currently has <code>replicas == 0</code>.</li>\n<li>There is recent activity (HTTP or schedule) for this function.</li>\n<li>All <code>DependsOn</code> functions are ready enough (as determined by SlimFaas).</li>\n<li>‚áí SlimFaas scales the function <strong>to <code>ReplicasAtStart</code></strong>.</li>\n</ul>\n</li>\n<li>\n<p><strong>From below min to <code>ReplicasAtStart</code></strong>:</p>\n<ul>\n<li>The function currently has <code>replicas &lt; ReplicasMin</code>.</li>\n<li>Dependencies are ready.</li>\n<li>‚áí SlimFaas scales the function up to <code>ReplicasAtStart</code>.</li>\n</ul>\n</li>\n</ol>\n<p>This ensures:</p>\n<ul>\n<li><strong>Only the <code>0 ‚Üí N</code> system can wake a function from 0</strong>,</li>\n<li>The function will start with a known initial capacity before the Prometheus AutoScaler adjusts it.</li>\n</ul>\n<h3>Time-based schedule (wake-up &amp; scale-down timeout)</h3>\n<p>The <code>SlimFaas/Schedule</code> annotation lets you:</p>\n<ul>\n<li>Declare <strong>wake-up times</strong> (treated as ‚Äúcalls‚Äù),</li>\n<li>Configure <strong>different scale-down timeouts by time of day</strong>.</li>\n</ul>\n<p>Annotation example:</p>\n<pre><code class=\"language-yaml hljs\">metadata:\n  annotations:\n    SlimFaas/Schedule: &gt;\n      {\n        \"TimeZoneID\": <span class=\"hljs-string\">\"Europe/Paris\"</span>,\n        <span class=\"hljs-string\">\"Default\"</span>: {\n          \"WakeUp\": [\n            <span class=\"hljs-string\">\"08:30\"</span>\n          ],\n          <span class=\"hljs-string\">\"ScaleDownTimeout\"</span>: [\n            { \"<span class=\"hljs-selector-tag\">Time</span>\": <span class=\"hljs-string\">\"08:30\"</span>, <span class=\"hljs-string\">\"Value\"</span>: <span class=\"hljs-number\">3600</span> },\n            { \"<span class=\"hljs-selector-tag\">Time</span>\": <span class=\"hljs-string\">\"18:30\"</span>, <span class=\"hljs-string\">\"Value\"</span>: <span class=\"hljs-number\">300</span> }\n          ]\n        }\n      }\n</code></pre>\n<ul>\n<li><code>TimeZoneID</code>: IANA time zone ID.</li>\n<li><code>WakeUp</code>: list of <code>HH:mm</code> times when the function is considered active (even without HTTP calls).</li>\n<li><code>ScaleDownTimeout</code>: list of time-based overrides for the inactivity timeout (<code>Value</code> is in seconds).</li>\n</ul>\n<p>This allows you, for example:</p>\n<ul>\n<li>Large timeout in business hours (keep pods warm),</li>\n<li>Short timeout at night (aggressive scale-down).</li>\n</ul>\n<hr>\n<h2>Configuring <code>N ‚Üí M</code> scale (Prometheus AutoScaler)</h2>\n<p>The Prometheus-based AutoScaler is activated by adding a <code>SlimFaas/Scale</code> annotation on the function‚Äôs Deployment. It <strong>only runs when the function has at least one pod</strong>.</p>\n<h3><code>SlimFaas/Scale</code> annotation structure (JSON)</h3>\n<p>The annotation is a JSON <code>ScaleConfig</code>:</p>\n<pre><code class=\"language-yaml hljs\"><span class=\"hljs-params\">metadata:</span>\n  <span class=\"hljs-params\">annotations:</span>\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">Scale:</span> <span class=\"hljs-operator\">&gt;</span>\n      {\n        <span class=\"hljs-string\">\"ReplicaMax\"</span>: <span class=\"hljs-number\">20</span>,\n        <span class=\"hljs-string\">\"Triggers\"</span>: [\n          {\n            <span class=\"hljs-string\">\"MetricType\"</span>: <span class=\"hljs-string\">\"AverageValue\"</span>,\n            <span class=\"hljs-string\">\"MetricName\"</span>: <span class=\"hljs-string\">\"rps_per_pod\"</span>,\n            <span class=\"hljs-string\">\"Query\"</span>: <span class=\"hljs-string\">\"sum(rate(http_server_requests_seconds_count{namespace=\"</span>${namespace}<span class=\"hljs-string\">\",job=\"</span>${app}<span class=\"hljs-string\">\"}[1m]))\"</span>,\n            <span class=\"hljs-string\">\"Threshold\"</span>: <span class=\"hljs-number\">50</span>\n          }\n        ],\n        <span class=\"hljs-string\">\"Behavior\"</span>: {\n          <span class=\"hljs-string\">\"ScaleUp\"</span>: {\n            <span class=\"hljs-string\">\"StabilizationWindowSeconds\"</span>: <span class=\"hljs-number\">0</span>,\n            <span class=\"hljs-string\">\"Policies\"</span>: [\n              { <span class=\"hljs-string\">\"Type\"</span>: <span class=\"hljs-string\">\"Percent\"</span>, <span class=\"hljs-string\">\"Value\"</span>: <span class=\"hljs-number\">100</span>, <span class=\"hljs-string\">\"PeriodSeconds\"</span>: <span class=\"hljs-number\">15</span> },\n              { <span class=\"hljs-string\">\"Type\"</span>: <span class=\"hljs-string\">\"Pods\"</span>,    <span class=\"hljs-string\">\"Value\"</span>: <span class=\"hljs-number\">4</span>,   <span class=\"hljs-string\">\"PeriodSeconds\"</span>: <span class=\"hljs-number\">15</span> }\n            ]\n          },\n          <span class=\"hljs-string\">\"ScaleDown\"</span>: {\n            <span class=\"hljs-string\">\"StabilizationWindowSeconds\"</span>: <span class=\"hljs-number\">300</span>,\n            <span class=\"hljs-string\">\"Policies\"</span>: [\n              { <span class=\"hljs-string\">\"Type\"</span>: <span class=\"hljs-string\">\"Percent\"</span>, <span class=\"hljs-string\">\"Value\"</span>: <span class=\"hljs-number\">50</span>, <span class=\"hljs-string\">\"PeriodSeconds\"</span>: <span class=\"hljs-number\">30</span> }\n            ]\n          }\n        }\n      }\n</code></pre>\n<p>Main fields:</p>\n<ul>\n<li>\n<p><code>ReplicaMax</code>\nMaximum number of pods SlimFaas may ever scale this function to. <code>null</code> means no hard cap.</p>\n</li>\n<li>\n<p><code>Triggers</code>\nList of metrics-based scaling rules.</p>\n<p>Each trigger has:</p>\n<ul>\n<li><code>MetricType</code>: <code>\"AverageValue\"</code> or <code>\"Value\"</code>.\n<ul>\n<li><code>\"AverageValue\"</code>: threshold is interpreted as <strong>target per pod</strong>.</li>\n<li><code>\"Value\"</code>: threshold is interpreted as <strong>target for the total sum</strong>.</li>\n</ul>\n</li>\n<li><code>MetricName</code>: human-readable metric name (for doc / logs).</li>\n<li><code>Query</code>: PromQL query that <strong>must return a scalar</strong> (single numeric value).</li>\n<li><code>Threshold</code>: target value for the metric (per pod or total, depending on <code>MetricType</code>).</li>\n</ul>\n</li>\n<li>\n<p><code>Behavior</code>\nConfiguration of scale-up / scale-down behavior:</p>\n<ul>\n<li><code>ScaleUp</code>: policies and stabilization for increasing replicas.</li>\n<li><code>ScaleDown</code>: policies and stabilization for decreasing replicas.</li>\n</ul>\n</li>\n</ul>\n<h3>Scaling formula (HPA/KEDA-style)</h3>\n<p>For each trigger, the AutoScaler computes:</p>\n<pre><code class=\"language-text hljs\"><span class=\"hljs-attribute\">desiredReplicasTrigger</span> <span class=\"hljs-operator\">=</span> ceil(currentReplicas * (currentMetric / Threshold))\n</code></pre>\n<p>Then:</p>\n<ul>\n<li>\n<p>If <strong>multiple triggers</strong> are configured:</p>\n<ul>\n<li>The AutoScaler takes the <strong>maximum</strong> of all <code>desiredReplicasTrigger</code>.</li>\n</ul>\n</li>\n<li>\n<p>The result is then constrained by:</p>\n<ul>\n<li><code>ReplicasMin</code> and <code>ReplicaMax</code>,</li>\n<li>scale-up / scale-down policies,</li>\n<li>stabilization windows.</li>\n</ul>\n</li>\n</ul>\n<p>If all triggers are invalid (NaN, Inf, negative, invalid PromQL, etc.), the AutoScaler <strong>keeps the current replica count</strong>, only clamping it between <code>ReplicasMin</code> and <code>ReplicaMax</code>.</p>\n<h3>Policies and stabilization</h3>\n<p>The <code>Behavior.ScaleUp.Policies</code> and <code>Behavior.ScaleDown.Policies</code> define how fast the scaler is allowed to change the number of pods:</p>\n<pre><code class=\"language-jsonc hljs\"><span class=\"hljs-string\">\"Behavior\"</span>: {\n  <span class=\"hljs-string\">\"ScaleUp\"</span>: {\n    <span class=\"hljs-string\">\"StabilizationWindowSeconds\"</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-string\">\"Policies\"</span>: [\n      { <span class=\"hljs-string\">\"Type\"</span>: <span class=\"hljs-string\">\"Percent\"</span>, <span class=\"hljs-string\">\"Value\"</span>: <span class=\"hljs-number\">100</span>, <span class=\"hljs-string\">\"PeriodSeconds\"</span>: <span class=\"hljs-number\">15</span> },\n      { <span class=\"hljs-string\">\"Type\"</span>: <span class=\"hljs-string\">\"Pods\"</span>,    <span class=\"hljs-string\">\"Value\"</span>: <span class=\"hljs-number\">4</span>,   <span class=\"hljs-string\">\"PeriodSeconds\"</span>: <span class=\"hljs-number\">15</span> }\n    ]\n  },\n  <span class=\"hljs-string\">\"ScaleDown\"</span>: {\n    <span class=\"hljs-string\">\"StabilizationWindowSeconds\"</span>: <span class=\"hljs-number\">300</span>,\n    <span class=\"hljs-string\">\"Policies\"</span>: [\n      { <span class=\"hljs-string\">\"Type\"</span>: <span class=\"hljs-string\">\"Percent\"</span>, <span class=\"hljs-string\">\"Value\"</span>: <span class=\"hljs-number\">50</span>, <span class=\"hljs-string\">\"PeriodSeconds\"</span>: <span class=\"hljs-number\">30</span> }\n    ]\n  }\n}\n</code></pre>\n<p>Conceptually:</p>\n<ul>\n<li>\n<p>For <strong>scale-up</strong>:</p>\n<ul>\n<li>Each policy defines a <strong>maximum allowed increase</strong> (either percentage or absolute pod count).</li>\n<li>SlimFaas picks the <strong>most aggressive</strong> policy (maximum allowed increase).</li>\n</ul>\n</li>\n<li>\n<p>For <strong>scale-down</strong>:</p>\n<ul>\n<li>Each policy defines a <strong>maximum allowed decrease</strong>.</li>\n<li>SlimFaas picks the <strong>most conservative</strong> policy (smallest allowed decrease).</li>\n</ul>\n</li>\n<li>\n<p><code>StabilizationWindowSeconds</code>:</p>\n<ul>\n<li>For scale-down, a non-zero window makes SlimFaas look at the <strong>max desired replicas</strong> in the recent window to avoid flapping.</li>\n<li>For scale-up, you can also use a stabilization window, but the default is usually <code>0</code>.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2>PromQL support &amp; current limitations</h2>\n<p>SlimFaas embeds a <strong>small PromQL evaluator</strong> that is focused on autoscaling use cases.\nIt supports a <strong>restricted but practical subset</strong> of PromQL, and always evaluates the\nquery to a <strong>single scalar</strong> that can be used by the AutoScaler.</p>\n<blockquote>\n<p>If a query cannot be parsed, or ultimately evaluates to <code>NaN</code> / <code>Infinity</code>,\nthe AutoScaler treats it as ‚Äúno data‚Äù and keeps the current replica count\n(subject to <code>ReplicasMin</code> / <code>ReplicaMax</code>).</p>\n</blockquote>\n<h3>Supported query patterns</h3>\n<h4>1. Instant and range selectors</h4>\n<ul>\n<li>\n<p><strong>Instant selector</strong></p>\n<pre><code class=\"language-promql hljs\">http_server_requests_seconds_count{<span class=\"hljs-attribute\">namespace</span>=<span class=\"hljs-string\">\"default\"</span>, <span class=\"hljs-attribute\">job</span>=<span class=\"hljs-string\">\"fibonacci\"</span>}\n</code></pre>\n<p>The evaluator loads all time series that match the metric name and label filters,\nand keeps the latest value per series.</p>\n</li>\n<li>\n<p><strong>Range selector</strong> (used with functions like <code>rate</code>, <code>max_over_time</code>, etc.)</p>\n<pre><code class=\"language-promql hljs\">http_server_requests_seconds_count{<span class=\"hljs-keyword\">namespace</span>=\"<span class=\"hljs-symbol\">default</span>\", <span class=\"hljs-symbol\">job</span>=\"<span class=\"hljs-symbol\">fibonacci</span>\"}[<span class=\"hljs-symbol\">1m</span>]\n</code></pre>\n<p>Supported duration units: <code>s</code>, <code>m</code>, <code>h</code> (e.g. <code>15s</code>, <code>1m</code>, <code>5m</code>, <code>1h</code>).</p>\n</li>\n<li>\n<p><strong>Label matchers</strong></p>\n<ul>\n<li>Exact match: <code>label=\"value\"</code></li>\n<li>Regex match: <code>label=~\"value.*\"</code></li>\n</ul>\n<p>(Negative operators <code>!=</code> / <code>!~</code> are <strong>not</strong> supported.)</p>\n</li>\n</ul>\n<h4>2. Arithmetic on scalars</h4>\n<p>Once a query has been reduced to a scalar, you can combine expressions with basic\narithmetic:</p>\n<pre><code class=\"language-promql hljs\"><span class=\"hljs-function\"><span class=\"hljs-title\">max_over_time</span><span class=\"hljs-params\">(slimfaas_function_queue_ready_items{function=<span class=\"hljs-string\">\"fibonacci\"</span>}[<span class=\"hljs-number\">30s</span>])</span></span> / <span class=\"hljs-number\">100</span>\n</code></pre>\n<p>Supported operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> (no comparison or logical operators).</p>\n<h4>3. <code>rate()</code> on counters</h4>\n<pre><code class=\"language-promql hljs\">rate(http_server_requests_seconds_count{<span class=\"hljs-keyword\">namespace</span>=\"<span class=\"hljs-symbol\">default</span>\", <span class=\"hljs-symbol\">job</span>=\"<span class=\"hljs-symbol\">fibonacci</span>\"}[<span class=\"hljs-symbol\">1m</span>])\n</code></pre>\n<ul>\n<li>Computes the <strong>per-series rate</strong> based on the first and last sample in the window.</li>\n<li>Resets (counter going backwards) are ignored.</li>\n<li>The evaluator returns the <strong>sum of the rates of all matching series</strong>.</li>\n</ul>\n<p>This is typically combined with <code>sum()</code> (or used directly) as a global RPS estimator.</p>\n<h4>4. Aggregations: <code>sum</code>, <code>min</code>, <code>max</code>, <code>avg</code></h4>\n<p>All aggregations operate on scalars or on the per-bucket maps used for histograms.</p>\n<p>Common patterns:</p>\n<ul>\n<li>\n<p><strong>Global sum</strong></p>\n<pre><code class=\"language-promql hljs\">sum(rate(http_server_requests_seconds_count{<span class=\"hljs-keyword\">namespace</span>=\"<span class=\"hljs-symbol\">default</span>\", <span class=\"hljs-symbol\">job</span>=\"<span class=\"hljs-symbol\">fibonacci</span>\"}[<span class=\"hljs-symbol\">1m</span>]))\n</code></pre>\n</li>\n<li>\n<p><strong>Global min / max / avg</strong> of a scalar expression:</p>\n<pre><code class=\"language-promql hljs\">max(\n  rate(http_server_requests_seconds_count{<span class=\"hljs-keyword\">namespace</span>=\"<span class=\"hljs-symbol\">default</span>\", <span class=\"hljs-symbol\">job</span>=\"<span class=\"hljs-symbol\">fibonacci</span>\"}[<span class=\"hljs-symbol\">1m</span>])\n)\n</code></pre>\n</li>\n<li>\n<p><strong>Aggregations with <code>by (label)</code></strong></p>\n<pre><code class=\"language-promql hljs\">sum by (le) (\n  rate(http_server_requests_seconds_bucket{<span class=\"hljs-keyword\">namespace</span>=\"<span class=\"hljs-symbol\">default</span>\", <span class=\"hljs-symbol\">job</span>=\"<span class=\"hljs-symbol\">fibonacci</span>\"}[<span class=\"hljs-symbol\">1m</span>])\n)\n</code></pre>\n<p>This form is specifically supported for histogram use cases (see below).\nFor non-histogram use cases, the <code>by (...)</code> support is limited and mostly\nintended as an internal building block for <code>histogram_quantile</code>.</p>\n</li>\n</ul>\n<blockquote>\n<p>For autoscaling, you should assume that the final result is always a single scalar.\nEven when using <code>by (...)</code> aggregations, the evaluator eventually collapses the\ndata to a scalar to feed the scaling formula.</p>\n</blockquote>\n<h4>5. Histograms and <code>histogram_quantile()</code></h4>\n<p>SlimFaas supports the standard Prometheus pattern for computing quantiles from histograms:</p>\n<pre><code class=\"language-promql hljs\">histogram_quantile(\n  <span class=\"hljs-number\">0.95</span>,\n  sum by (<span class=\"hljs-name\">le</span>) (\n    <span class=\"hljs-name\">rate</span>(<span class=\"hljs-name\">http_server_requests_seconds_bucket</span>{namespace=<span class=\"hljs-string\">\"default\"</span>, job=<span class=\"hljs-string\">\"fibonacci\"</span>}[<span class=\"hljs-number\">1</span>m])\n  )\n)\n</code></pre>\n<p>Supported semantics:</p>\n<ul>\n<li>The <code>_bucket</code> metric is treated as a <strong>cumulative histogram</strong>.</li>\n<li><code>rate(...[win])</code> converts buckets to per-second rates.</li>\n<li><code>sum by (le)</code> merges per-pod buckets into <strong>global buckets per <code>le</code></strong>.</li>\n<li><code>histogram_quantile(phi, ‚Ä¶)</code> then applies Prometheus‚Äô official algorithm\nto compute the <code>phi</code> quantile (e.g. <code>0.95</code> for p95).</li>\n</ul>\n<p>The result is a <strong>single scalar</strong> representing the chosen quantile in seconds.</p>\n<h4>6. <code>max_over_time()</code> on gauges</h4>\n<p>SlimFaas exposes several queue-related metrics as gauges, for example:</p>\n<pre><code class=\"language-promql hljs\"><span class=\"hljs-keyword\">slimfaas_function_queue_ready_items</span>{<span class=\"hljs-keyword\">function</span><span class=\"hljs-operator\">=</span><span class=\"hljs-string\">\"fibonacci\"</span>}\n<span class=\"hljs-keyword\">slimfaas_function_queue_in_flight_items</span>{<span class=\"hljs-keyword\">function</span><span class=\"hljs-operator\">=</span><span class=\"hljs-string\">\"fibonacci\"</span>}\n<span class=\"hljs-keyword\">slimfaas_function_queue_retry_pending_items</span>{<span class=\"hljs-keyword\">function</span><span class=\"hljs-operator\">=</span><span class=\"hljs-string\">\"fibonacci\"</span>}\n</code></pre>\n<p>You can use <code>max_over_time()</code> to look at the worst case in a recent window:</p>\n<pre><code class=\"language-promql hljs\"><span class=\"hljs-function\"><span class=\"hljs-title\">max_over_time</span><span class=\"hljs-params\">(slimfaas_function_queue_ready_items{function=<span class=\"hljs-string\">\"fibonacci\"</span>}[<span class=\"hljs-number\">30s</span>])</span></span>\n</code></pre>\n<p>Semantics:</p>\n<ul>\n<li>For each matching series, the evaluator computes the <strong>maximum value</strong> in the window.</li>\n<li>The global result is the <strong>maximum of all series maxima</strong>.</li>\n<li>The output is a scalar, perfect for triggers such as ‚Äúmax queue length over 30s‚Äù.</li>\n</ul>\n<p>This is particularly useful for queue-driven autoscaling.</p>\n<h3>Practical examples for triggers</h3>\n<p>Here are a few ready-to-use patterns for <code>SlimFaas/Scale.Triggers[].Query</code>.</p>\n<h4>Example: total RPS per function</h4>\n<pre><code class=\"language-jsonc hljs\">{\n  <span class=\"hljs-string\">\"MetricType\"</span>: <span class=\"hljs-string\">\"AverageValue\"</span>,\n  <span class=\"hljs-string\">\"MetricName\"</span>: <span class=\"hljs-string\">\"rps_per_pod\"</span>,\n  <span class=\"hljs-string\">\"Query\"</span>: <span class=\"hljs-string\">\"sum(rate(http_server_requests_seconds_count{namespace=\"</span><span class=\"hljs-variable\">${namespace}</span><span class=\"hljs-string\">\",job=\"</span><span class=\"hljs-variable\">${app}</span><span class=\"hljs-string\">\"}[1m]))\"</span>,\n  <span class=\"hljs-string\">\"Threshold\"</span>: <span class=\"hljs-number\">20</span>\n}\n</code></pre>\n<p>Interpretation:</p>\n<ul>\n<li>The query returns the total RPS for the function.</li>\n<li>With <code>MetricType = \"AverageValue\"</code>, the AutoScaler treats <code>Threshold = 20</code>\nas ‚Äútarget 20 RPS <strong>per pod</strong>‚Äù.</li>\n</ul>\n<h4>Example: max queue length over 30 seconds</h4>\n<pre><code class=\"language-jsonc hljs\">{\n  <span class=\"hljs-string\">\"MetricType\"</span>: <span class=\"hljs-string\">\"Value\"</span>,\n  <span class=\"hljs-string\">\"MetricName\"</span>: <span class=\"hljs-string\">\"queue_max_30s\"</span>,\n  <span class=\"hljs-string\">\"Query\"</span>: <span class=\"hljs-string\">\"max_over_time(slimfaas_function_queue_ready_items{function=\"</span><span class=\"hljs-variable\">${app}</span><span class=\"hljs-string\">\"}[30s])\"</span>,\n  <span class=\"hljs-string\">\"Threshold\"</span>: <span class=\"hljs-number\">200</span>\n}\n</code></pre>\n<p>Interpretation:</p>\n<ul>\n<li>If the maximum queue length over the last 30 seconds is 400 and the threshold is 200,\nthe AutoScaler will aim for <code>desiredReplicas ‚âà 2√ó currentReplicas</code> (subject to policies).</li>\n</ul>\n<h4>Example: p95 latency</h4>\n<pre><code class=\"language-jsonc hljs\">{\n  <span class=\"hljs-string\">\"MetricType\"</span>: <span class=\"hljs-string\">\"AverageValue\"</span>,\n  <span class=\"hljs-string\">\"MetricName\"</span>: <span class=\"hljs-string\">\"p95_latency\"</span>,\n  <span class=\"hljs-string\">\"Query\"</span>: <span class=\"hljs-string\">\"histogram_quantile(0.95, sum by (le) ( rate(http_server_requests_seconds_bucket{namespace=\"</span><span class=\"hljs-variable\">${namespace}</span><span class=\"hljs-string\">\",job=\"</span><span class=\"hljs-variable\">${app}</span><span class=\"hljs-string\">\"}[1m]) ))\"</span>,\n  <span class=\"hljs-string\">\"Threshold\"</span>: <span class=\"hljs-number\">0.500</span>\n}\n</code></pre>\n<p>Interpretation:</p>\n<ul>\n<li>The query computes the p95 latency in seconds.</li>\n<li><code>Threshold = 0.500</code> means ‚Äúkeep p95 latency around 500ms per pod‚Äù.</li>\n</ul>\n<h3>Current limitations &amp; gotchas</h3>\n<p>The SlimFaas PromQL mini-evaluator is intentionally simple. Notable limitations:</p>\n<ol>\n<li>\n<p><strong>Scalar only</strong></p>\n<ul>\n<li>All queries must reduce to a <strong>single scalar</strong>.</li>\n<li>There's no support for returning full time series or vectors.</li>\n<li>The scaler sums or aggregates all matching series internally.</li>\n</ul>\n</li>\n<li>\n<p><strong>Limited function set</strong></p>\n<ul>\n<li>Supported: <code>rate</code>, <code>sum</code>, <code>min</code>, <code>max</code>, <code>avg</code>, <code>histogram_quantile</code>, <code>max_over_time</code>,\nplus basic arithmetic <code>+ - * /</code>.</li>\n<li>Not supported: <code>count</code>, <code>stddev</code>, <code>quantile_over_time</code>, <code>increase</code>, <code>irate</code>, <code>predict_linear</code>,\n<code>clamp_*</code>, <code>label_replace</code>, etc.</li>\n</ul>\n</li>\n<li>\n<p><strong>No logical or comparison operators</strong></p>\n<ul>\n<li>Operators such as <code>&gt;</code>, <code>&lt;</code>, <code>==</code>, <code>and</code>, <code>or</code>, <code>unless</code> are not supported.</li>\n<li>Use these expressions only in dashboards, not in SlimFaas AutoScaler queries.</li>\n</ul>\n</li>\n<li>\n<p><strong>Simple label matchers only</strong></p>\n<ul>\n<li>Supported: <code>=</code> and <code>=~</code>.</li>\n<li>Not supported: <code>!=</code>, <code>!~</code>.</li>\n<li>Make sure your metric cardinality and label design fit this constraint.</li>\n</ul>\n</li>\n<li>\n<p><strong>Range selector constraints</strong></p>\n<ul>\n<li>Only simple durations with <code>s</code>, <code>m</code>, <code>h</code> are supported (e.g. <code>15s</code>, <code>1m</code>, <code>5m</code>).</li>\n<li>Nested subqueries like <code>rate(sum(...)[5m:1m])</code> are <strong>not</strong> supported.</li>\n</ul>\n</li>\n<li>\n<p><strong>Histogram assumptions</strong></p>\n<ul>\n<li>Histogram support assumes standard Prometheus conventions:\n<ul>\n<li>cumulative <code>_bucket</code> metrics,</li>\n<li>a <code>le</code> label with numeric bounds or <code>+Inf</code>.</li>\n</ul>\n</li>\n<li>The recommended pattern is exactly:\n<code>histogram_quantile(phi, sum by (le) ( rate(&lt;metric&gt;_bucket[win]) ))</code>.</li>\n</ul>\n</li>\n<li>\n<p><strong>Evaluation time</strong></p>\n<ul>\n<li>By default, the evaluator uses the <strong>latest timestamp</strong> found in the metrics store\nas the ‚Äúnow‚Äù for range selections.</li>\n<li>You can override it in code (<code>Evaluate(query, nowUnixSeconds)</code>), but the SlimFaas\nAutoScaler uses the default.</li>\n</ul>\n</li>\n<li>\n<p><strong>Error handling</strong></p>\n<ul>\n<li>A parse error or unsupported construct results in a <code>FormatException</code>\nwhich is caught by the AutoScaler and logged as a warning.</li>\n<li>Any resulting <code>NaN</code> / <code>Infinity</code> is treated as ‚Äúno data‚Äù and the current replica\ncount is preserved (within <code>ReplicasMin</code> / <code>ReplicaMax</code>).</li>\n</ul>\n</li>\n</ol>\n<p>In short: <strong>keep queries simple and scalar-oriented</strong>. If a query would be hard to express\nwithout advanced PromQL features, it is probably better suited for dashboards than for\ndirect autoscaling decisions.</p>\n<hr>\n<h2>Metrics scraping internals</h2>\n<p>SlimFaas does not talk directly to Prometheus. Instead, it has its own lightweight\nscraping and storage pipeline that is optimized for autoscaling signals.</p>\n<p>At a high level:</p>\n<ul>\n<li>Only the <strong>metrics HTTP endpoint</strong> is called on your pods.</li>\n<li>SlimFaas keeps in memory <strong>only the metric keys that have been requested at least once</strong>.</li>\n<li>A single SlimFaas node is responsible for scraping and persisting metrics.</li>\n<li>All nodes evaluate PromQL against a <strong>shared, synchronized store</strong> with a <strong>30-minute retention window</strong>.</li>\n</ul>\n<hr>\n<h3>Scraping cycle (every 5 seconds)</h3>\n<p>Every 5 seconds, a background worker (<code>MetricsScrapingWorker</code>) runs on the\n<strong>designated scraping node</strong> and performs the following steps:</p>\n<ol>\n<li>\n<p>Discover pods that:</p>\n<ul>\n<li>are part of your SlimFaas workloads, and</li>\n<li>expose Prometheus-compatible HTTP metrics via annotations.</li>\n</ul>\n</li>\n<li>\n<p>For each pod that has Prometheus HTTP annotations (for example):</p>\n<ul>\n<li><code>prometheus.io/scrape: \"true\"</code></li>\n<li><code>prometheus.io/scheme: \"http\"</code> (optional, defaults to HTTP)</li>\n<li><code>prometheus.io/port: \"5000\"</code> (optional)</li>\n<li><code>prometheus.io/path: \"/metrics\"</code> (optional)</li>\n</ul>\n<p>the worker builds the target URL:</p>\n<pre><code class=\"language-text hljs\">&lt;scheme&gt;<span class=\"hljs-symbol\">://&lt;pod-ip&gt;</span><span class=\"hljs-symbol\">:&lt;port&gt;&lt;path&gt;</span>\n</code></pre>\n</li>\n<li>\n<p>It sends a <strong>single HTTP GET</strong> to the metrics endpoint of each such pod and\nparses the standard Prometheus exposition format:</p>\n<pre><code class=\"language-text hljs\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">metric_name</span>&gt;</span></span><span class=\"hljs-template-variable\">{optional_labels}</span><span class=\"language-xml\"> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">value</span>&gt;</span> [optional_timestamp]\n</span></code></pre>\n</li>\n<li>\n<p>For each parsed metric line, it decides whether to store the sample\nin the in-memory <code>IMetricsStore</code> (see next section).</p>\n</li>\n</ol>\n<p>Only this lightweight HTTP metrics scrape happens every 5 seconds; no other\n‚Äúdebug‚Äù or control endpoints are called on your functions during scraping.</p>\n<hr>\n<h3>Requested metric keys only</h3>\n<p>To keep memory and I/O usage small, SlimFaas does <strong>not</strong> store every metric\nit sees. Instead, it maintains a dynamic allow-list of <strong>requested metric names</strong>\nvia <code>IRequestedMetricsRegistry</code>.</p>\n<p>A metric name becomes ‚Äúrequested‚Äù in two situations:</p>\n<ol>\n<li>It appears in a <code>SlimFaas/Scale.Triggers[].Query</code> used by the AutoScaler.</li>\n<li>It is referenced at least once in a call to the debug endpoint\n<a href=\"#debug-http-endpoints\"><code>POST /debug/promql/eval</code></a>.</li>\n</ol>\n<p>During scraping:</p>\n<ul>\n<li>For each metric line, SlimFaas:\n<ul>\n<li>extracts the metric name (e.g. <code>http_server_requests_seconds_count</code>,\n<code>slimfaas_function_queue_ready_items</code>, etc.),</li>\n<li>checks if this name is present in the requested set,</li>\n<li><strong>only stores the sample if the metric name is requested</strong>.</li>\n</ul>\n</li>\n</ul>\n<p>All other metrics are simply ignored.</p>\n<h4>Enabling new metrics via debug</h4>\n<p>If you run a debug query that uses a metric which was <strong>not</strong> previously requested,\nfor example:</p>\n<pre><code class=\"language-bash hljs\">curl -X <span class=\"hljs-keyword\">POST</span> <span class=\"hljs-string\">\"http://localhost:5000/debug/promql/eval\"</span>   -<span class=\"hljs-keyword\">H</span> <span class=\"hljs-string\">\"Content-Type: application/json\"</span>   -<span class=\"hljs-keyword\">d</span> '{\n    <span class=\"hljs-string\">\"query\"</span>: <span class=\"hljs-string\">\"max_over_time(some_new_metric{function=\"</span>fibonacci<span class=\"hljs-string\">\"}[30s])\"</span>\n  }'\n</code></pre>\n<p>then:</p>\n<ul>\n<li><code>IRequestedMetricsRegistry</code> will add <code>some_new_metric</code> to the requested set,</li>\n<li>from the next scraping cycles onward, the scraper will start storing\nsamples for <code>some_new_metric</code> (provided the pods actually expose it).</li>\n</ul>\n<p>This is not retroactive: data is only available from the moment the metric\nbecomes requested.</p>\n<hr>\n<h3>Scraping node, master node, and database synchronization</h3>\n<p>In a SlimFaas cluster there are two important roles:</p>\n<ul>\n<li>\n<p>The <strong>master node</strong>\nResponsible for orchestration and scaling decisions:</p>\n<ul>\n<li>runs <code>ReplicasService.CheckScaleAsync</code>,</li>\n<li>runs <code>ScaleReplicasWorker</code>,</li>\n<li>applies scaling changes to Kubernetes.</li>\n</ul>\n</li>\n<li>\n<p>The <strong>designated scraping node</strong> (not the master)\nResponsible for metrics ingestion:</p>\n<ul>\n<li>runs <code>MetricsScrapingWorker</code>,</li>\n<li>calls the metrics endpoints on your pods every 5 seconds,</li>\n<li>updates the in-memory <code>IMetricsStore</code>,</li>\n<li>periodically serializes the metrics store to the SlimFaas database\n(for example under the key <code>metrics:store</code>).</li>\n</ul>\n</li>\n</ul>\n<p>All <strong>other</strong> SlimFaas nodes, including the master, do <strong>not</strong> scrape your pods.\nInstead, they:</p>\n<ol>\n<li>Periodically read the serialized metrics store from the SlimFaas database.</li>\n<li>Hydrate their local <code>IMetricsStore</code> from this binary snapshot.</li>\n<li>Evaluate PromQL queries locally against this hydrated store\n(for autoscaler triggers or debug requests).</li>\n</ol>\n<p>This architecture:</p>\n<ul>\n<li>avoids hammering your functions with multiple scrapers,</li>\n<li>keeps network traffic and CPU overhead low,</li>\n<li>still allows every node to have a consistent view of recent metrics.</li>\n</ul>\n<hr>\n<h3>Retention window (30 minutes)</h3>\n<p>The in-memory <code>IMetricsStore</code> is a time-bucketed structure, keyed by Unix timestamps\nin seconds. On each scrape:</p>\n<ul>\n<li>new samples are added under the <strong>current timestamp bucket</strong>,</li>\n<li>older buckets that fall outside the retention window are removed.</li>\n</ul>\n<p>By default, SlimFaas keeps <strong>only 30 minutes of data</strong> in the store.</p>\n<p>Practical implications:</p>\n<ul>\n<li>PromQL range windows like <code>[15s]</code>, <code>[30s]</code>, <code>[1m]</code>, <code>[5m]</code>, <code>[15m]</code> work as expected.</li>\n<li>Longer windows (e.g. <code>[1h]</code>, <code>[6h]</code>) effectively see only the <strong>most recent\n30 minutes</strong> of samples and may produce misleading results.</li>\n<li>The autoscaler and debug endpoints always work on ‚Äúrecent‚Äù data, which keeps\nmemory usage predictable and bounded.</li>\n</ul>\n<p>When combined with the requested-metrics filter, this retention model gives you\na compact, autoscaling-oriented time series store: just enough history to compute\nrates, quantiles and queue peaks, without trying to be a full Prometheus\nreplacement.</p>\n<hr>\n<h2>Debug HTTP endpoints</h2>\n<p>SlimFaas exposes two <strong>debug HTTP endpoints</strong> to help you understand:</p>\n<ul>\n<li>Which metrics are actually stored in the in-memory metrics store,</li>\n<li>How your PromQL expressions are evaluated by the internal PromQL mini-evaluator.</li>\n</ul>\n<blockquote>\n<p>These endpoints are designed for <strong>local development, QA, and troubleshooting</strong>.\nIn production, you should restrict access to them (authN/authZ, network policies, etc.)\nor expose them only to operators.</p>\n</blockquote>\n<hr>\n<h3><code>POST /debug/promql/eval</code></h3>\n<p>Evaluate a PromQL expression <strong>against the current in-memory metrics store</strong> and see\nthe scalar value that the AutoScaler would use.</p>\n<p>This endpoint also:</p>\n<ul>\n<li>Enables PromQL-driven scraping via <code>IMetricsScrapingGuard</code> (so the scraping worker\nwill actively collect metrics referenced in queries),</li>\n<li>Registers the metric names found in the query via <code>IRequestedMetricsRegistry</code>\n(so the scraper can focus on relevant metrics).</li>\n</ul>\n<h4>Request</h4>\n<ul>\n<li>Method: <code>POST</code></li>\n<li>Path: <code>/debug/promql/eval</code></li>\n<li>Body (JSON, <code>PromQlRequest</code>):</li>\n</ul>\n<pre><code class=\"language-jsonc hljs\">{\n  <span class=\"hljs-string\">\"query\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"max_over_time(slimfaas_function_queue_ready_items{function=\"</span>fibonacci<span class=\"hljs-string\">\"}[30s])\"</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-string\">\"nowUnixSeconds\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">1732100000</span>\n}\n</code></pre>\n<p>Fields:</p>\n<ul>\n<li><code>query</code> (required): the PromQL expression to evaluate.</li>\n<li><code>nowUnixSeconds</code> (optional): Unix timestamp (seconds) to use as ‚Äúnow‚Äù for range selectors.\nIf omitted, the evaluator uses the <strong>latest timestamp available in the store</strong>.</li>\n</ul>\n<h4>Successful response (200)</h4>\n<p>Body (JSON, <code>PromQlResponse</code>):</p>\n<pre><code class=\"language-json hljs\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">\"value\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">42.0</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>This is the final scalar value returned by the PromQL mini-evaluator.</p>\n<h4>Example: evaluate queue length over 30 seconds</h4>\n<pre><code class=\"language-bash hljs\">curl -X <span class=\"hljs-keyword\">POST</span> <span class=\"hljs-string\">\"http://localhost:5000/debug/promql/eval\"</span>   -<span class=\"hljs-keyword\">H</span> <span class=\"hljs-string\">\"Content-Type: application/json\"</span>   -<span class=\"hljs-keyword\">d</span> '{\n    <span class=\"hljs-string\">\"query\"</span>: <span class=\"hljs-string\">\"max_over_time(slimfaas_function_queue_ready_items{function=\"</span>fibonacci<span class=\"hljs-string\">\"}[30s])\"</span>\n  }'\n</code></pre>\n<p>Possible response:</p>\n<pre><code class=\"language-json hljs\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">\"value\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">128</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<h4>Example: evaluate RPS</h4>\n<pre><code class=\"language-bash hljs\">curl -X POST <span class=\"hljs-string\">\"http://localhost:5000/debug/promql/eval\"</span>   -H <span class=\"hljs-string\">\"Content-Type: application/json\"</span>   -d <span class=\"hljs-string\">'{\n    \"</span>query<span class=\"hljs-string\">\": \"</span><span class=\"hljs-built_in\">sum</span>(rate(http_server_requests_seconds_count{namespace=<span class=\"hljs-string\">\"default\"</span>,job=<span class=\"hljs-string\">\"fibonacci\"</span>}[<span class=\"hljs-number\">1</span>m]))<span class=\"hljs-string\">\"\n  }'</span>\n</code></pre>\n<p>Possible response:</p>\n<pre><code class=\"language-json hljs\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">\"value\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">17.352941176470587</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>You can compare this value with the trigger <code>Threshold</code> to understand\nhow the AutoScaler will compute <code>desiredReplicas</code>.</p>\n<h4>Error responses</h4>\n<p>The endpoint returns structured errors when something goes wrong.</p>\n<p><strong>1. Missing or empty query</strong></p>\n<pre><code class=\"language-bash hljs\">curl -X POST <span class=\"hljs-string\">\"http://localhost:5000/debug/promql/eval\"</span>   -H <span class=\"hljs-string\">\"Content-Type: application/json\"</span>   -d <span class=\"hljs-string\">'{\"</span>query<span class=\"hljs-string\">\": \"</span><span class=\"hljs-string\">\"}'</span>\n</code></pre>\n<p>Response (400):</p>\n<pre><code class=\"language-json hljs\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">\"error\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"query is required\"</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p><strong>2. Parse error / unsupported syntax</strong></p>\n<pre><code class=\"language-json hljs\">{\n  <span class=\"hljs-comment\">\"error\"</span>: <span class=\"hljs-comment\">\"Unexpected trailing characters in query\"</span>\n}\n</code></pre>\n<p><strong>3. Result is NaN or Infinity</strong></p>\n<p>For example, when there is no data or a division by zero:</p>\n<pre><code class=\"language-json hljs\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">\"error\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"PromQL result is NaN or Infinity (probably no data or division by zero).\"</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p><strong>4. Internal error</strong></p>\n<p>Unexpected exceptions during evaluation are returned as RFC 7807 problem details:</p>\n<pre><code class=\"language-json hljs\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">\"type\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"about:blank\"</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">\"title\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"Evaluation error\"</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">\"status\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">500</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">\"detail\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"Some internal exception message...\"</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>Use this endpoint to <strong>dry-run</strong> any PromQL expression before using it\nin <code>SlimFaas/Scale.Triggers[].Query</code>.</p>\n<hr>\n<h3><code>GET /debug/store</code></h3>\n<p>Inspect a <strong>summary of the in-memory metrics store</strong> and see which metric names are\ncurrently being ‚Äúrequested‚Äù by the autoscaler and by your debug PromQL calls.</p>\n<p>This endpoint does <em>not</em> dump all the raw samples. Instead, it returns a compact view\nof what‚Äôs inside the store.</p>\n<h4>Request</h4>\n<ul>\n<li>Method: <code>GET</code></li>\n<li>Path: <code>/debug/store</code></li>\n<li>Body: none</li>\n</ul>\n<h4>Response (200)</h4>\n<p>Body (JSON, <code>MetricsStoreDebugResponse</code>):</p>\n<pre><code class=\"language-json hljs\">{\n  <span class=\"hljs-string\">\"requestedMetricNames\"</span>: [\n    <span class=\"hljs-string\">\"http_server_requests_seconds_count\"</span>,\n    <span class=\"hljs-string\">\"slimfaas_function_queue_ready_items\"</span>\n  ],\n  <span class=\"hljs-string\">\"timestampBuckets\"</span>: <span class=\"hljs-number\">48</span>,\n  <span class=\"hljs-string\">\"seriesCount\"</span>: <span class=\"hljs-number\">1262</span>,\n  <span class=\"hljs-string\">\"totalPoints\"</span>: <span class=\"hljs-number\">1262</span>\n}\n</code></pre>\n<p>Fields:</p>\n<ul>\n<li>\n<p><code>requestedMetricNames</code>\nList of distinct metric names registered via <code>IRequestedMetricsRegistry</code>, typically from:</p>\n<ul>\n<li><code>SlimFaas/Scale.Triggers[].Query</code> (autoscaler triggers),</li>\n<li>calls to <code>POST /debug/promql/eval</code>.</li>\n</ul>\n<p>If this list is empty, it usually means that no PromQL-based queries\nhave been registered yet, and the scraper may not be focusing on any metric.</p>\n</li>\n<li>\n<p><code>timestampBuckets</code>\nNumber of distinct timestamps currently stored. This is roughly the size\nof the internal rolling window in ‚Äúbuckets‚Äù.</p>\n</li>\n<li>\n<p><code>seriesCount</code>\nNumber of time series (deployment √ó pod √ó metric key) in the store.</p>\n</li>\n<li>\n<p><code>totalPoints</code>\nTotal number of points <code>(timestamp, series)</code> currently stored.</p>\n</li>\n</ul>\n<h4>Example: inspect the metrics store</h4>\n<pre><code class=\"language-bash hljs\"><span class=\"hljs-attribute\">curl</span> <span class=\"hljs-string\">\"http://localhost:5000/debug/store\"</span>\n</code></pre>\n<p>Example response:</p>\n<pre><code class=\"language-json hljs\">{\n  <span class=\"hljs-string\">\"requestedMetricNames\"</span>: [\n    <span class=\"hljs-string\">\"http_server_requests_seconds_count\"</span>,\n    <span class=\"hljs-string\">\"slimfaas_function_queue_ready_items\"</span>\n  ],\n  <span class=\"hljs-string\">\"timestampBuckets\"</span>: <span class=\"hljs-number\">4</span>,\n  <span class=\"hljs-string\">\"seriesCount\"</span>: <span class=\"hljs-number\">8</span>,\n  <span class=\"hljs-string\">\"totalPoints\"</span>: <span class=\"hljs-number\">8</span>\n}\n</code></pre>\n<p>How to read this:</p>\n<ul>\n<li>Your PromQL queries currently reference two metric names\n(HTTP request counter and queue length gauge).</li>\n<li>The store holds data for 4 different timestamps.</li>\n<li>There are 8 logical series (e.g. 2 metrics √ó 4 pods).</li>\n<li>Each series has one point per timestamp, so <code>totalPoints = 8</code>.</li>\n</ul>\n<p>If <code>timestampBuckets</code> stays at <code>0</code> or <code>1</code> for a long time, it usually means that:</p>\n<ul>\n<li>the scraping worker is not running,</li>\n<li>or it cannot reach your pods (annotations, network, etc.).</li>\n</ul>\n<p>Using this endpoint together with <code>POST /debug/promql/eval</code> gives you a very quick way\nto understand ‚Äúwhat SlimFaas sees‚Äù when making autoscaling decisions.</p>\n<hr>\n<h2>Decision algorithm details</h2>\n<p>High-level logic for each periodic tick of <code>CheckScaleAsync</code>:</p>\n<pre><code class=\"language-text hljs\">for each function:\n\n<span class=\"hljs-bullet\">  1.</span> Read current replicas and configuration (annotations).\n\n<span class=\"hljs-bullet\">  2.</span> Compute \"last activity\" timestamp using:\n<span class=\"hljs-bullet\">     -</span> HTTP history,\n<span class=\"hljs-bullet\">     -</span> schedule wake-up times,\n<span class=\"hljs-bullet\">     -</span> dependency activity.\n\n<span class=\"hljs-bullet\">  3.</span> HTTP/schedule-based 0‚ÜíN / N‚Üí0 system:\n\n<span class=\"hljs-bullet\">     -</span> If inactivity is longer than the current timeout:\n<span class=\"hljs-code\">         desiredReplicas = ReplicasMin\n</span>\n<span class=\"hljs-bullet\">     -</span> Else if (replicas == 0 or replicas &lt; ReplicasMin) and dependencies are ready:\n<span class=\"hljs-code\">         desiredReplicas = ReplicasAtStart\n</span>\n<span class=\"hljs-bullet\">     -</span> Else:\n<span class=\"hljs-code\">         desiredReplicas = currentReplicas\n</span>\n<span class=\"hljs-bullet\">  4.</span> Prometheus-based N‚ÜíM system:\n\n<span class=\"hljs-bullet\">     -</span> If there is a valid SlimFaas/Scale annotation\n<span class=\"hljs-code\">       AND currentReplicas &gt; 0:\n</span>\n<span class=\"hljs-code\">         desiredReplicas = AutoScaler(desiredReplicas, metrics...)\n</span>\n<span class=\"hljs-bullet\">  5.</span> If desiredReplicas != currentReplicas:\n<span class=\"hljs-code\">       call Kubernetes Scale (Deployment replicas) for this function.\n</span></code></pre>\n<p>Key points:</p>\n<ul>\n<li>The <strong>HTTP/schedule system always runs first</strong>, and is the only one that can propose a transition from <code>0</code> to <code>&gt; 0</code>.</li>\n<li>The <strong>Prometheus AutoScaler only runs if <code>currentReplicas &gt; 0</code></strong>.</li>\n<li>The final decision is applied only if <code>desiredReplicas</code> differs from the current value.</li>\n</ul>\n<hr>\n<h2>Configuration examples</h2>\n<h3>1. Simple RPS-based autoscaling with scale-to-zero</h3>\n<p>This example:</p>\n<ul>\n<li>Scales based on <strong>requests per second (RPS)</strong>,</li>\n<li>Allows <strong>scale-to-zero</strong> after 5 minutes of inactivity,</li>\n<li>Starts with 1 pod when waking up.</li>\n</ul>\n<pre><code class=\"language-yaml hljs\"><span class=\"hljs-params\">apiVersion:</span> apps<span class=\"hljs-symbol\">/v1</span>\n<span class=\"hljs-params\">kind:</span> Deployment\n<span class=\"hljs-params\">metadata:</span>\n  <span class=\"hljs-params\">name:</span> fibonacci\n  <span class=\"hljs-params\">namespace:</span> default\n  <span class=\"hljs-params\">annotations:</span>\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">ReplicasMin:</span> <span class=\"hljs-string\">\"0\"</span>\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">ReplicasAtStart:</span> <span class=\"hljs-string\">\"1\"</span>\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">TimeoutSecondBeforeSetReplicasMin:</span> <span class=\"hljs-string\">\"300\"</span>\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">Scale:</span> <span class=\"hljs-operator\">&gt;</span>\n      {\n        <span class=\"hljs-string\">\"ReplicaMax\"</span>: <span class=\"hljs-number\">10</span>,\n        <span class=\"hljs-string\">\"Triggers\"</span>: [\n          {\n            <span class=\"hljs-string\">\"MetricType\"</span>: <span class=\"hljs-string\">\"AverageValue\"</span>,\n            <span class=\"hljs-string\">\"MetricName\"</span>: <span class=\"hljs-string\">\"rps_per_pod\"</span>,\n            <span class=\"hljs-string\">\"Query\"</span>: <span class=\"hljs-string\">\"sum(rate(http_server_requests_seconds_count{namespace=<span class=\"hljs-char escape_\">\\\"</span><span class=\"hljs-subst\">${namespace}</span><span class=\"hljs-char escape_\">\\\"</span>,job=<span class=\"hljs-char escape_\">\\\"</span><span class=\"hljs-subst\">${app}</span><span class=\"hljs-char escape_\">\\\"</span>}[1m]))\"</span>,\n            <span class=\"hljs-string\">\"Threshold\"</span>: <span class=\"hljs-number\">20</span>\n          }\n        ]\n      }\n<span class=\"hljs-params\">spec:</span>\n  <span class=\"hljs-params\">replicas:</span> <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-comment\"># ...</span>\n</code></pre>\n<p>Interpretation:</p>\n<ul>\n<li>\n<p>Target: <strong>20 RPS per pod</strong>.</p>\n</li>\n<li>\n<p>Scale-up/down formula:</p>\n<pre><code class=\"language-text hljs\"><span class=\"hljs-attribute\">desiredReplicas</span> <span class=\"hljs-operator\">=</span> ceil(currentReplicas * (currentRps / <span class=\"hljs-number\">20</span>))\n</code></pre>\n</li>\n<li>\n<p>After 5 minutes with no activity (HTTP or schedule), SlimFaas scales down to 0.</p>\n</li>\n</ul>\n<h3>2. Combined trigger: RPS per pod + queue length</h3>\n<p>This example:</p>\n<ul>\n<li>Uses two triggers:\n<ul>\n<li>RPS per pod,</li>\n<li>Total queue length for this function.</li>\n</ul>\n</li>\n<li>Uses per-pod and total constraints.</li>\n</ul>\n<pre><code class=\"language-yaml hljs\"><span class=\"hljs-params\">apiVersion:</span> apps<span class=\"hljs-symbol\">/v1</span>\n<span class=\"hljs-params\">kind:</span> Deployment\n<span class=\"hljs-params\">metadata:</span>\n  <span class=\"hljs-params\">name:</span> my-queue-driven-func\n  <span class=\"hljs-params\">namespace:</span> default\n  <span class=\"hljs-params\">annotations:</span>\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">ReplicasMin:</span> <span class=\"hljs-string\">\"1\"</span>\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">ReplicasAtStart:</span> <span class=\"hljs-string\">\"2\"</span>\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">TimeoutSecondBeforeSetReplicasMin:</span> <span class=\"hljs-string\">\"600\"</span>\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">Scale:</span> <span class=\"hljs-operator\">&gt;</span>\n      {\n        <span class=\"hljs-string\">\"ReplicaMax\"</span>: <span class=\"hljs-number\">50</span>,\n        <span class=\"hljs-string\">\"Triggers\"</span>: [\n          {\n            <span class=\"hljs-string\">\"MetricType\"</span>: <span class=\"hljs-string\">\"AverageValue\"</span>,\n            <span class=\"hljs-string\">\"MetricName\"</span>: <span class=\"hljs-string\">\"rps_per_pod\"</span>,\n            <span class=\"hljs-string\">\"Query\"</span>: <span class=\"hljs-string\">\"sum(rate(http_server_requests_seconds_count{namespace=<span class=\"hljs-char escape_\">\\\"</span><span class=\"hljs-subst\">${namespace}</span><span class=\"hljs-char escape_\">\\\"</span>,job=<span class=\"hljs-char escape_\">\\\"</span><span class=\"hljs-subst\">${app}</span><span class=\"hljs-char escape_\">\\\"</span>}[1m]))\"</span>,\n            <span class=\"hljs-string\">\"Threshold\"</span>: <span class=\"hljs-number\">30</span>\n          },\n          {\n            <span class=\"hljs-string\">\"MetricType\"</span>: <span class=\"hljs-string\">\"Value\"</span>,\n            <span class=\"hljs-string\">\"MetricName\"</span>: <span class=\"hljs-string\">\"queue_length\"</span>,\n            <span class=\"hljs-string\">\"Query\"</span>: <span class=\"hljs-string\">\"sum(slimfaas_function_queue_ready_items{function=<span class=\"hljs-char escape_\">\\\"</span><span class=\"hljs-subst\">${app}</span><span class=\"hljs-char escape_\">\\\"</span>})\"</span>,\n            <span class=\"hljs-string\">\"Threshold\"</span>: <span class=\"hljs-number\">200</span>\n          }\n        ],\n        <span class=\"hljs-string\">\"Behavior\"</span>: {\n          <span class=\"hljs-string\">\"ScaleUp\"</span>: {\n            <span class=\"hljs-string\">\"StabilizationWindowSeconds\"</span>: <span class=\"hljs-number\">0</span>,\n            <span class=\"hljs-string\">\"Policies\"</span>: [\n              { <span class=\"hljs-string\">\"Type\"</span>: <span class=\"hljs-string\">\"Percent\"</span>, <span class=\"hljs-string\">\"Value\"</span>: <span class=\"hljs-number\">100</span>, <span class=\"hljs-string\">\"PeriodSeconds\"</span>: <span class=\"hljs-number\">15</span> },\n              { <span class=\"hljs-string\">\"Type\"</span>: <span class=\"hljs-string\">\"Pods\"</span>,    <span class=\"hljs-string\">\"Value\"</span>: <span class=\"hljs-number\">10</span>,  <span class=\"hljs-string\">\"PeriodSeconds\"</span>: <span class=\"hljs-number\">15</span> }\n            ]\n          },\n          <span class=\"hljs-string\">\"ScaleDown\"</span>: {\n            <span class=\"hljs-string\">\"StabilizationWindowSeconds\"</span>: <span class=\"hljs-number\">300</span>,\n            <span class=\"hljs-string\">\"Policies\"</span>: [\n              { <span class=\"hljs-string\">\"Type\"</span>: <span class=\"hljs-string\">\"Percent\"</span>, <span class=\"hljs-string\">\"Value\"</span>: <span class=\"hljs-number\">50</span>, <span class=\"hljs-string\">\"PeriodSeconds\"</span>: <span class=\"hljs-number\">30</span> }\n            ]\n          }\n        }\n      }\n<span class=\"hljs-params\">spec:</span>\n  <span class=\"hljs-params\">replicas:</span> <span class=\"hljs-number\">2</span>\n  <span class=\"hljs-comment\"># ...</span>\n</code></pre>\n<p>Behavior:</p>\n<ul>\n<li>For each trigger, the AutoScaler computes a desired replica count.</li>\n<li>The final <code>desiredReplicas</code> is the <strong>maximum</strong> of:\n<ul>\n<li>the desired from RPS trigger,</li>\n<li>the desired from queue length trigger.</li>\n</ul>\n</li>\n</ul>\n<h3>3. Business-hours warmup via Schedule</h3>\n<p>Keep pods warm during business hours, aggressive scale-down at night:</p>\n<pre><code class=\"language-yaml hljs\"><span class=\"hljs-params\">apiVersion:</span> apps<span class=\"hljs-symbol\">/v1</span>\n<span class=\"hljs-params\">kind:</span> Deployment\n<span class=\"hljs-params\">metadata:</span>\n  <span class=\"hljs-params\">name:</span> business-func\n  <span class=\"hljs-params\">namespace:</span> default\n  <span class=\"hljs-params\">annotations:</span>\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">ReplicasMin:</span> <span class=\"hljs-string\">\"1\"</span>\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">ReplicasAtStart:</span> <span class=\"hljs-string\">\"2\"</span>\n    SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">Schedule:</span> <span class=\"hljs-operator\">&gt;</span>\n      {\n        <span class=\"hljs-string\">\"TimeZoneID\"</span>: <span class=\"hljs-string\">\"Europe/Paris\"</span>,\n        <span class=\"hljs-string\">\"Default\"</span>: {\n          <span class=\"hljs-string\">\"WakeUp\"</span>: [\n            <span class=\"hljs-string\">\"08:30\"</span>\n          ],\n          <span class=\"hljs-string\">\"ScaleDownTimeout\"</span>: [\n            { <span class=\"hljs-string\">\"Time\"</span>: <span class=\"hljs-string\">\"08:30\"</span>, <span class=\"hljs-string\">\"Value\"</span>: <span class=\"hljs-number\">3600</span> },\n            { <span class=\"hljs-string\">\"Time\"</span>: <span class=\"hljs-string\">\"18:30\"</span>, <span class=\"hljs-string\">\"Value\"</span>: <span class=\"hljs-number\">300</span> }\n          ]\n        }\n      }\n<span class=\"hljs-params\">spec:</span>\n  <span class=\"hljs-comment\"># ...</span>\n</code></pre>\n<ul>\n<li>At 08:30 local time:\n<ul>\n<li>The function is ‚Äúvirtually called‚Äù and can be scaled up to <code>ReplicasAtStart</code>.</li>\n<li>Inactivity timeout is 3600 seconds (1 hour).</li>\n</ul>\n</li>\n<li>After 18:30:\n<ul>\n<li>Timeout is only 300 seconds (5 minutes), so pods can scale down quickly.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2>Best practices</h2>\n<ol>\n<li>\n<p><strong>Always set a meaningful <code>ReplicaMax</code></strong>\nAvoid unbounded scaling in case of incorrect thresholds or noisy metrics.</p>\n</li>\n<li>\n<p><strong>Choose <code>ReplicasMin</code> carefully</strong></p>\n<ul>\n<li>Use <code>0</code> only when you accept cold start latency.</li>\n<li>Use <code>1</code> or more for critical, low-latency functions.</li>\n</ul>\n</li>\n<li>\n<p><strong>Use reasonable PromQL windows</strong></p>\n<ul>\n<li>Prefer metrics such as <code>rate(...[1m])</code> or <code>rate(...[5m])</code> rather than raw counters.</li>\n<li>Avoid overly short windows that create noisy signals.</li>\n</ul>\n</li>\n<li>\n<p><strong>Be conservative with scale-down</strong></p>\n<ul>\n<li>Add a <code>ScaleDown</code> stabilization window.</li>\n<li>Use smaller percent values (e.g., 50%) to avoid aggressive shrink.</li>\n</ul>\n</li>\n<li>\n<p><strong>Never rely on Prometheus to wake from 0</strong></p>\n<ul>\n<li>Prometheus metrics require pods to be running and scraped.</li>\n<li>In SlimFaas, <strong>only HTTP/schedule controls 0 ‚Üí N</strong>.</li>\n</ul>\n</li>\n<li>\n<p><strong>Document each trigger</strong></p>\n<ul>\n<li>Use <code>MetricName</code> for clear semantic names.</li>\n<li>Keep the PromQL queries in team documentation or dashboards.</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2>Observability &amp; debugging</h2>\n<p>To understand and debug autoscaling behavior:</p>\n<ol>\n<li>\n<p><strong>Logs from ReplicasService / ScaleReplicasWorker</strong></p>\n<ul>\n<li>\n<p>Debug logs show time left before scale-down.</p>\n</li>\n<li>\n<p>Info logs show scaling decisions:</p>\n<pre><code class=\"language-text hljs\"><span class=\"hljs-attribute\">Scale</span> up {Deployment} <span class=\"hljs-selector-tag\">from</span> {Current} <span class=\"hljs-selector-tag\">to</span> {Desired}\n<span class=\"hljs-attribute\">Scale</span> down {Deployment} <span class=\"hljs-selector-tag\">from</span> {Current} <span class=\"hljs-selector-tag\">to</span> {ReplicasMin}\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Logs from the AutoScaler / PromQL evaluator</strong></p>\n<ul>\n<li>Warnings when:\n<ul>\n<li>PromQL queries fail,</li>\n<li>Metric values are NaN or infinite,</li>\n<li>Thresholds are invalid.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Prometheus / Grafana dashboards</strong></p>\n<ul>\n<li>Visualize:\n<ul>\n<li>The PromQL used in triggers.</li>\n<li>The effective RPS, queue length, etc.</li>\n<li>The number of replicas per function over time.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Debug HTTP endpoints</strong></p>\n<ul>\n<li>Use <code>/debug/promql/eval</code> to validate PromQL expressions against the current store.</li>\n<li>Use <code>/debug/store</code> to check that metrics are being scraped and stored.</li>\n</ul>\n</li>\n<li>\n<p><strong>Metrics for desired vs actual replicas</strong></p>\n<ul>\n<li>Expose or log the desired replica count computed per tick for better visibility.</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2>FAQ</h2>\n<h3>Q1. Why does the AutoScaler never wake a function from 0?</h3>\n<p>By design:</p>\n<ul>\n<li>SlimFaas <strong>only allows the HTTP/schedule system to wake functions from 0</strong>.</li>\n<li>The Prometheus AutoScaler only adjusts <strong>existing</strong> capacity.</li>\n</ul>\n<p>This avoids relying on metrics that cannot exist while no pod is running.</p>\n<hr>\n<h3>Q2. What happens if all triggers return invalid metrics?</h3>\n<p>If all triggers in <code>SlimFaas/Scale</code> produce invalid values (NaN, Inf, negative, PromQL error):</p>\n<ul>\n<li>The AutoScaler ignores them.</li>\n<li>The replica count is left unchanged, except for:\n<ul>\n<li>enforcing <code>ReplicasMin</code>,</li>\n<li>enforcing <code>ReplicaMax</code>.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>Q3. How do I enable scale-to-zero?</h3>\n<p>Set:</p>\n<pre><code class=\"language-yaml hljs\"><span class=\"hljs-params\">annotations:</span>\n  SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">ReplicasMin:</span> <span class=\"hljs-string\">\"0\"</span>\n  SlimFaas<span class=\"hljs-operator\">/</span><span class=\"hljs-params\">TimeoutSecondBeforeSetReplicasMin:</span> <span class=\"hljs-string\">\"300\"</span>\n</code></pre>\n<p>After 300 seconds of inactivity (considering HTTP history, schedule, and dependencies), SlimFaas will scale the function down to 0.</p>\n<hr>\n<h3>Q4. How do I temporarily disable the Prometheus AutoScaler for a function?</h3>\n<p>Simply remove the <code>SlimFaas/Scale</code> annotation from the Deployment (or set it to an empty config with no triggers):</p>\n<pre><code class=\"language-yaml hljs\"><span class=\"hljs-attribute\">annotations</span><span class=\"hljs-punctuation\">:</span>\n  <span class=\"hljs-attribute\">SlimFaas/Scale</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&gt;</span>\n    <span class=\"hljs-attribute\">{\n      \"Triggers\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">[]</span>\n    }\n</code></pre>\n<p>With no valid triggers, the <code>N ‚Üí M</code> system will effectively be disabled; only <code>0 ‚Üí N</code> / <code>N ‚Üí 0</code> will remain active.</p>\n<hr>\n<h3>Q5. Can I combine several triggers for one function?</h3>\n<p>Yes.</p>\n<ul>\n<li>Each trigger computes its own desired replica count.</li>\n<li>The AutoScaler chooses the <strong>maximum</strong> of all trigger outputs.</li>\n<li>This lets you, for example, scale based on:\n<ul>\n<li>both RPS and queue length,</li>\n<li>or RPS and CPU usage, etc.</li>\n</ul>\n</li>\n</ul>\n</body></html>","metadata":{}},"__N_SSG":true}