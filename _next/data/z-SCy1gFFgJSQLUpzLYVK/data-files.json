{"pageProps":{"contentHtml":"<html><head></head><body><h1>Data temporary binary API</h1>\n<p>SlimFaas provides <strong>temporary binary storage</strong> through the <strong><code>/data/files</code></strong> endpoints.\nThis feature is designed for internal workflows (functions, jobs, agents, pipelines) that need to store and retrieve <strong>binary artifacts</strong> (PDF, ZIP, audio, PPTX, etc.) for a limited time.</p>\n<p>This page explains:</p>\n<ul>\n<li>how to use the <code>/data/files</code> API,</li>\n<li>how it works internally (cluster behavior, safety limits),</li>\n<li>how to configure <strong>Public vs Private</strong> access and override it via <strong>environment variables</strong>.</li>\n</ul>\n<hr>\n<h2>What is <code>/data/files</code> for?</h2>\n<p>Use <code>/data/files</code> when you need:</p>\n<ul>\n<li>a simple temporary store for binary artifacts</li>\n<li>a way to retrieve an artifact from any node in a SlimFaas cluster</li>\n<li>a solution that avoids shipping large binaries through the cluster’s consensus layer</li>\n</ul>\n<p><strong>Core idea</strong></p>\n<ul>\n<li>The <strong>binary content</strong> is stored on <strong>disk</strong>.</li>\n<li>The <strong>metadata</strong> (checksum, size, content type, filename, TTL) is stored in a <strong>cluster-consistent store</strong> so every node knows “what exists”.</li>\n</ul>\n<hr>\n<h2>API summary</h2>\n<p>Base path: <code>/data/files</code></p>\n<div class=\"table-scroll\" role=\"region\" aria-label=\"Scrollable table\" tabindex=\"0\"><table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Path</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>POST</code></td>\n<td><code>/data/files?id={id?}&amp;ttl={ms?}</code></td>\n<td>Store a binary artifact (request body = raw bytes)</td>\n</tr>\n<tr>\n<td><code>GET</code></td>\n<td><code>/data/files/{id}</code></td>\n<td>Download an artifact (auto-pull from another node if missing locally)</td>\n</tr>\n<tr>\n<td><code>DELETE</code></td>\n<td><code>/data/files/{id}</code></td>\n<td>Remove metadata (the artifact becomes inaccessible through the API)</td>\n</tr>\n<tr>\n<td><code>GET</code></td>\n<td><code>/data/files</code></td>\n<td>List known artifacts (metadata-based)</td>\n</tr>\n</tbody>\n</table></div>\n<hr>\n<h2>Store an artifact: <code>POST /data/files</code></h2>\n<h3>Request contract</h3>\n<ul>\n<li>Body: <strong>raw bytes</strong> (not multipart/form-data)</li>\n<li><strong><code>Content-Length</code> is recommended</strong> (for accurate concurrency accounting)</li>\n<li>Recommended headers:\n<ul>\n<li><code>Content-Type</code> (defaults to <code>application/octet-stream</code>)</li>\n<li><code>Content-Disposition</code> (to provide a download filename)</li>\n</ul>\n</li>\n</ul>\n<p>Query parameters:</p>\n<ul>\n<li><code>id</code> (optional): artifact identifier\n<ul>\n<li>If omitted, SlimFaas generates an id.</li>\n<li>Use URL-safe ids (letters, numbers, <code>.</code>, <code>_</code>, <code>-</code>).</li>\n</ul>\n</li>\n<li><code>ttl</code> (optional): time-to-live in <strong>milliseconds</strong>\n<ul>\n<li>Example: <code>ttl=600000</code> (10 minutes)</li>\n</ul>\n</li>\n</ul>\n<h3>Content-Length behavior (when missing or unknown)</h3>\n<p>SlimFaas streams the request body to disk. For its transfer safety guard (see <strong>256 MiB parallel limiter</strong>), SlimFaas normally relies on <code>Content-Length</code> to “reserve” the right byte budget.</p>\n<p>If <code>Content-Length</code> is <strong>missing</strong> or <strong>unknown</strong> (e.g., chunked transfer encoding), SlimFaas:</p>\n<ul>\n<li><strong>accepts the upload</strong></li>\n<li>logs a <strong>warning</strong></li>\n<li><strong>assumes the transfer is 20 MiB</strong> for the limiter accounting</li>\n</ul>\n<blockquote>\n<p>Recommendation\nProvide <code>Content-Length</code> whenever possible to get accurate concurrency behavior (especially behind proxies).</p>\n</blockquote>\n<h3>Responses</h3>\n<ul>\n<li><code>200 OK</code> with the artifact id as plain text</li>\n<li><code>400 Bad Request</code> if the id is invalid</li>\n</ul>\n<h3>Examples (curl)</h3>\n<p>Store an artifact for 10 minutes and keep a filename:</p>\n<pre><code class=\"language-bash hljs\">curl -X <span class=\"hljs-keyword\">POST</span> <span class=\"hljs-string\">\"http://&lt;slimfaas&gt;/data/files?ttl=600000\"</span>   -<span class=\"hljs-keyword\">H</span> <span class=\"hljs-string\">\"Content-Type: application/pdf\"</span>   -<span class=\"hljs-keyword\">H</span> <span class=\"hljs-string\">\"Content-Disposition: attachment; filename=\\\"</span><span class=\"hljs-keyword\">report</span>.pdf\\<span class=\"hljs-string\">\"\"</span>   --data-binary @./<span class=\"hljs-keyword\">report</span>.pdf\n</code></pre>\n<p>Store an artifact with a chosen id:</p>\n<pre><code class=\"language-bash hljs\">curl -X POST <span class=\"hljs-string\">\"http://&lt;slimfaas&gt;/data/files?id=my-artifact-001&amp;ttl=300000\"</span>   -H <span class=\"hljs-string\">\"Content-Type: application/octet-stream\"</span>   <span class=\"hljs-params\">--data-binary</span> @<span class=\"hljs-string\">./payload.bin</span>\n</code></pre>\n<hr>\n<h2>Download an artifact: <code>GET /data/files/{id}</code></h2>\n<h3>What happens on a download</h3>\n<p>When you request an artifact:</p>\n<ol>\n<li>SlimFaas reads the <strong>cluster-consistent metadata</strong> for <code>{id}</code> (checksum, size, content type, filename, TTL)</li>\n<li>It checks whether the binary exists locally and matches the expected checksum</li>\n<li>If missing, SlimFaas attempts to <strong>pull</strong> the binary from another cluster node that has it</li>\n<li>The response streams the binary to the client</li>\n</ol>\n<h3>Responses</h3>\n<ul>\n<li><code>200 OK</code> streamed response\n<ul>\n<li><code>Content-Type</code> from metadata (fallback <code>application/octet-stream</code>)</li>\n<li>a download filename if provided at upload time</li>\n</ul>\n</li>\n<li><code>400 Bad Request</code> if id is invalid</li>\n<li><code>404 Not Found</code> if metadata is missing/expired, or if no node can provide the binary</li>\n</ul>\n<h3>Example (curl)</h3>\n<pre><code class=\"language-bash hljs\"><span class=\"hljs-attribute\">curl</span> -L <span class=\"hljs-string\">\"http://&lt;slimfaas&gt;/data/files/my-artifact-001\"</span> -o my-artifact-<span class=\"hljs-number\">001</span>.bin\n</code></pre>\n<hr>\n<h2>Delete an artifact: <code>DELETE /data/files/{id}</code></h2>\n<p>This removes the <strong>metadata</strong> for the artifact.</p>\n<ul>\n<li><code>204 No Content</code> on success</li>\n<li><code>400 Bad Request</code> if id is invalid</li>\n</ul>\n<blockquote>\n<p>Important\nRemoving metadata makes the artifact inaccessible through the API (downloads return 404), even if the binary still exists on disk. Disk cleanup depends on your configured cleanup/expiration strategy.</p>\n</blockquote>\n<hr>\n<h2>List artifacts: <code>GET /data/files</code></h2>\n<p>Returns the list of known artifact ids (metadata-based) and their expiration information (if any). Expired entries are not returned.</p>\n<p>Example:</p>\n<pre><code class=\"language-bash hljs\"><span class=\"hljs-attribute\">curl</span> -s <span class=\"hljs-string\">\"http://&lt;slimfaas&gt;/data/files\"</span>\n</code></pre>\n<hr>\n<h2>Visibility &amp; security (Public vs Private)</h2>\n<p>All <code>/data/files</code> routes are protected by a <strong>data visibility</strong> setting.</p>\n<p>In <code>appsettings.json</code>:</p>\n<pre><code class=\"language-json hljs\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">\"Data\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">\"DefaultVisibility\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"Private\"</span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<h3>Behavior</h3>\n<ul>\n<li><strong>Public</strong>: anyone who can reach SlimFaas can call <code>/data/files</code></li>\n<li><strong>Private</strong> (recommended): only <strong>internal</strong> requests are allowed\nExternal requests are typically answered with <strong>404 Not Found</strong> (intentionally “hidden”).</li>\n</ul>\n<hr>\n<h2>Overriding visibility via environment variables</h2>\n<p>SlimFaas supports standard configuration overrides via environment variables.</p>\n<p>To override:</p>\n<ul>\n<li><code>Data:DefaultVisibility</code></li>\n</ul>\n<p>Use:</p>\n<ul>\n<li><code>Data__DefaultVisibility</code></li>\n</ul>\n<h3>Example: set <code>/data/files</code> to Public</h3>\n<h4>Docker / Docker Compose</h4>\n<pre><code class=\"language-bash hljs\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-attribute\">Data__DefaultVisibility</span>=Public\n</code></pre>\n<h4>Kubernetes Deployment (excerpt)</h4>\n<pre><code class=\"language-yaml hljs\"><span class=\"hljs-params\">env:</span>\n  <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Data__DefaultVisibility\n    <span class=\"hljs-params\">value:</span> <span class=\"hljs-string\">\"Public\"</span>\n</code></pre>\n<p>To keep it private (explicit):</p>\n<pre><code class=\"language-yaml hljs\"><span class=\"hljs-params\">env:</span>\n  <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Data__DefaultVisibility\n    <span class=\"hljs-params\">value:</span> <span class=\"hljs-string\">\"Private\"</span>\n</code></pre>\n<blockquote>\n<p>Notes</p>\n<ul>\n<li>This setting affects all data routes that are guarded by the same visibility filter, including <code>/data/files</code>.</li>\n<li>Use <code>Public</code> / <code>Private</code> for clarity.</li>\n</ul>\n</blockquote>\n<hr>\n<h2>How it works internally (high-level)</h2>\n<h3>1) Metadata is cluster-consistent; content is disk-backed</h3>\n<p>For <code>/data/files</code>:</p>\n<ul>\n<li><strong>metadata</strong> is stored in a cluster-consistent store so every node has the same view of what exists and how to serve it</li>\n<li><strong>binary content</strong> is stored on disk on the node that received the POST request</li>\n</ul>\n<p>This avoids moving large binaries through the cluster’s consensus layer.</p>\n<h3>2) Cluster distribution model: announce + pull</h3>\n<p>SlimFaas does not block the POST by pushing the binary to all nodes.</p>\n<p>Instead:</p>\n<ol>\n<li>The node that stored the artifact announces “I have <code>{id}</code> with checksum <code>{sha}</code>”</li>\n<li>Other nodes can <strong>pull</strong> the artifact in the background</li>\n<li>If a client requests an artifact from a node that doesn’t have it locally, that node can <strong>pull on demand</strong></li>\n</ol>\n<p>This yields eventual distribution with minimal upload latency.</p>\n<h3>Diagrams (simplified)</h3>\n<div class=\"mermaid\">flowchart LR\n  %% 1) POST path — Upload + announce (fast)\n\n  C[Client] --&gt;|POST /data/files| A[Node A]\n  A --&gt;|write binary| D_A[(Disk on Node A)]\n  A --&gt;|\"store metadata (id, sha, len, ttl...)\"| M[(Cluster-consistent metadata)]\n  A --&gt;|announce id + sha| BUS[(Cluster announce bus)]\n\n</div>\n<div class=\"mermaid\">flowchart LR\n  %% 2) Background distribution — announce → async queue → worker → pull\n\n  BUS[(Cluster announce bus)] --&gt;|event: id + sha| RX[Node B Listener]\n  RX --&gt;|enqueue announce| Q[(AnnounceQueue)]\n  Q --&gt; W[BackgroundPullWorker]\n  W --&gt;|\"pull in background&lt;br/&gt;GET /cluster/files/{id}?sha=...\"| P[Pull client]\n  P --&gt;|download from Node A| D_A[(Disk on Node A)]\n  W --&gt;|verify sha + write| D_B[(Disk on Node B)]\n\n</div>\n<div class=\"mermaid\">flowchart LR\n  %% 3) GET path — Read local or pull on demand\n\n  C[Client] --&gt;|\"GET /data/files/{id}\"| X[Node B]\n  X --&gt;|read metadata| M[(Cluster-consistent metadata)]\n  X --&gt; HAS{Has file locally?}\n  HAS --&gt;|yes| D_B[(Disk on Node B)]\n  HAS --&gt;|no| P[\"Pull on demand&lt;br/&gt;GET /cluster/files/{id}?sha=...\"]\n  P --&gt;|download from Node A| D_A[(Disk on Node A)]\n  X --&gt;|stream binary| C\n\n\n</div>\n<hr>\n<h2>The 256 MiB parallel limiter (safety guard)</h2>\n<p>SlimFaas applies a safety guard that limits concurrent binary transfers to roughly:</p>\n<ul>\n<li><strong>256 MiB in parallel</strong></li>\n</ul>\n<p>Meaning:</p>\n<ul>\n<li>each in-flight transfer reserves a “byte budget” equal to its size</li>\n<li>new transfers wait if starting them would exceed the budget</li>\n<li>a single artifact larger than 256 MiB can run only if it is <strong>alone</strong></li>\n</ul>\n<p>When <code>Content-Length</code> is missing/unknown, SlimFaas uses <strong>20 MiB</strong> as the reserved size for that transfer (and logs a warning).</p>\n<p><strong>This is not a strict memory cap</strong>; it’s a concurrency limiter.</p>\n<hr>\n<h2>Storage &amp; durability</h2>\n<p><code>/data/files</code> is disk-backed:</p>\n<ul>\n<li>If storage is ephemeral, artifacts may disappear on pod restart.</li>\n<li>For durability, mount a persistent volume.</li>\n<li>Artifacts can be re-pulled from other nodes only while at least one node still has the content <strong>and</strong> metadata still exists.</li>\n</ul>\n<hr>\n<h2>Troubleshooting</h2>\n<h3>Upload logs a warning about Content-Length</h3>\n<p>Your client/proxy sent the request without <code>Content-Length</code> (often chunked transfer).</p>\n<p>SlimFaas will still accept the upload, but it will <strong>assume 20 MiB</strong> for concurrency accounting.\nFix: ensure uploads have a known length (e.g., <code>curl --data-binary @file</code>) and verify proxy settings if you want precise limiter behavior.</p>\n<h3>404 Not Found on download</h3>\n<ul>\n<li>metadata expired or was deleted</li>\n<li>no node currently has the binary (restart, cleanup, ephemeral storage)</li>\n<li>temporary unavailability during cluster convergence</li>\n</ul>\n<hr>\n<h2>Quick reference</h2>\n<ul>\n<li>Store: <code>POST /data/files?id={id?}&amp;ttl={ms?}</code></li>\n<li>Download: <code>GET /data/files/{id}</code></li>\n<li>Delete: <code>DELETE /data/files/{id}</code></li>\n<li>List: <code>GET /data/files</code></li>\n<li>Visibility config: <code>Data:DefaultVisibility = Public | Private</code></li>\n<li>Env override: <code>Data__DefaultVisibility=Public</code></li>\n</ul>\n</body></html>","metadata":{}},"__N_SSG":true}