{"pageProps":{"contentHtml":"<html><head></head><body><h1>Data temporary binary API</h1>\n<p>SlimFaas provides <strong>temporary binary storage</strong> through the <strong><code>/data/files</code></strong> endpoints.\nThis feature is designed for internal workflows (functions, jobs, agents, pipelines) that need to store and retrieve <strong>binary artifacts</strong> (PDF, ZIP, audio, PPTX, etc.) for a limited time.</p>\n<p>This page explains:</p>\n<ul>\n<li>how to use the <code>/data/files</code> API,</li>\n<li>how it works internally (cluster behavior, safety limits),</li>\n<li>how to configure <strong>Public vs Private</strong> access and override it via <strong>environment variables</strong>.</li>\n</ul>\n<hr>\n<h2>What is <code>/data/files</code> for?</h2>\n<p>Use <code>/data/files</code> when you need:</p>\n<ul>\n<li>a simple temporary store for binary artifacts</li>\n<li>a way to retrieve an artifact from any node in a SlimFaas cluster</li>\n<li>a solution that avoids shipping large binaries through the cluster’s consensus layer</li>\n</ul>\n<p><strong>Core idea</strong></p>\n<ul>\n<li>The <strong>binary content</strong> is stored on <strong>disk</strong>.</li>\n<li>The <strong>metadata</strong> (checksum, size, content type, filename, TTL) is stored in a <strong>cluster-consistent store</strong> so every node knows “what exists”.</li>\n</ul>\n<hr>\n<h2>API summary</h2>\n<p>Base path: <code>/data/files</code></p>\n<div class=\"table-scroll\" role=\"region\" aria-label=\"Scrollable table\" tabindex=\"0\"><table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Path</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>POST</code></td>\n<td><code>/data/files?id={id?}&amp;ttl={ms?}</code></td>\n<td>Store a binary artifact (request body = raw bytes)</td>\n</tr>\n<tr>\n<td><code>GET</code></td>\n<td><code>/data/files/{id}</code></td>\n<td>Download an artifact (auto-pull from another node if missing locally)</td>\n</tr>\n<tr>\n<td><code>DELETE</code></td>\n<td><code>/data/files/{id}</code></td>\n<td>Remove metadata (the artifact becomes inaccessible through the API)</td>\n</tr>\n<tr>\n<td><code>GET</code></td>\n<td><code>/data/files</code></td>\n<td>List known artifacts (metadata-based)</td>\n</tr>\n</tbody>\n</table></div>\n<hr>\n<h2>Store an artifact: <code>POST /data/files</code></h2>\n<h3>Request contract</h3>\n<ul>\n<li>Body: <strong>raw bytes</strong> (not multipart/form-data)</li>\n<li>Required header: <strong><code>Content-Length</code></strong></li>\n<li>Recommended headers:\n<ul>\n<li><code>Content-Type</code> (defaults to <code>application/octet-stream</code>)</li>\n<li><code>Content-Disposition</code> (to provide a download filename)</li>\n</ul>\n</li>\n</ul>\n<p>Query parameters:</p>\n<ul>\n<li><code>id</code> (optional): artifact identifier\n<ul>\n<li>If omitted, SlimFaas generates an id.</li>\n<li>Use URL-safe ids (letters, numbers, <code>.</code>, <code>_</code>, <code>-</code>).</li>\n</ul>\n</li>\n<li><code>ttl</code> (optional): time-to-live in <strong>milliseconds</strong>\n<ul>\n<li>Example: <code>ttl=600000</code> (10 minutes)</li>\n</ul>\n</li>\n</ul>\n<h3>Why <code>Content-Length</code> is required</h3>\n<p>SlimFaas streams the request body to disk. To apply its transfer safety guard (see <strong>256 MiB parallel limiter</strong>), SlimFaas must know the total size upfront.</p>\n<p>If the request uses chunked transfer encoding (unknown length), the upload is rejected with:</p>\n<ul>\n<li><strong>411 Length Required</strong></li>\n</ul>\n<h3>Responses</h3>\n<ul>\n<li><code>200 OK</code> with the artifact id as plain text</li>\n<li><code>400 Bad Request</code> if the id is invalid</li>\n<li><code>411 Length Required</code> if <code>Content-Length</code> is missing/unknown</li>\n</ul>\n<h3>Examples (curl)</h3>\n<p>Store an artifact for 10 minutes and keep a filename:</p>\n<pre><code class=\"language-bash hljs\">curl -X <span class=\"hljs-keyword\">POST</span> <span class=\"hljs-string\">\"http://&lt;slimfaas&gt;/data/files?ttl=600000\"</span> \\\n  -<span class=\"hljs-keyword\">H</span> <span class=\"hljs-string\">\"Content-Type: application/pdf\"</span> \\\n  -<span class=\"hljs-keyword\">H</span> <span class=\"hljs-string\">\"Content-Disposition: attachment; filename=\\\"</span><span class=\"hljs-keyword\">report</span>.pdf\\<span class=\"hljs-string\">\"\"</span> \\\n  --data-binary @./<span class=\"hljs-keyword\">report</span>.pdf\n</code></pre>\n<p>Store an artifact with a chosen id:</p>\n<pre><code class=\"language-bash hljs\"><span class=\"hljs-attribute\">curl</span> -X POST <span class=\"hljs-string\">\"http://&lt;slimfaas&gt;/data/files?id=my-artifact-001&amp;ttl=300000\"</span> <span class=\"hljs-punctuation\">\\\n</span>  -H <span class=\"hljs-string\">\"Content-Type: application/octet-stream\"</span> <span class=\"hljs-punctuation\">\\\n</span>  --data-binary @./payload.bin\n</code></pre>\n<hr>\n<h2>Download an artifact: <code>GET /data/files/{id}</code></h2>\n<h3>What happens on a download</h3>\n<p>When you request an artifact:</p>\n<ol>\n<li>SlimFaas reads the <strong>cluster-consistent metadata</strong> for <code>{id}</code> (checksum, size, content type, filename, TTL)</li>\n<li>It checks whether the binary exists locally and matches the expected checksum</li>\n<li>If missing, SlimFaas attempts to <strong>pull</strong> the binary from another cluster node that has it</li>\n<li>The response streams the binary to the client</li>\n</ol>\n<h3>Responses</h3>\n<ul>\n<li><code>200 OK</code> streamed response\n<ul>\n<li><code>Content-Type</code> from metadata (fallback <code>application/octet-stream</code>)</li>\n<li>a download filename if provided at upload time</li>\n</ul>\n</li>\n<li><code>400 Bad Request</code> if id is invalid</li>\n<li><code>404 Not Found</code> if metadata is missing/expired, or if no node can provide the binary</li>\n</ul>\n<h3>Example (curl)</h3>\n<pre><code class=\"language-bash hljs\"><span class=\"hljs-attribute\">curl</span> -L <span class=\"hljs-string\">\"http://&lt;slimfaas&gt;/data/files/my-artifact-001\"</span> -o my-artifact-<span class=\"hljs-number\">001</span>.bin\n</code></pre>\n<hr>\n<h2>Delete an artifact: <code>DELETE /data/files/{id}</code></h2>\n<p>This removes the <strong>metadata</strong> for the artifact.</p>\n<ul>\n<li><code>204 No Content</code> on success</li>\n<li><code>400 Bad Request</code> if id is invalid</li>\n</ul>\n<blockquote>\n<p>Important\nRemoving metadata makes the artifact inaccessible through the API (downloads return 404), even if the binary still exists on disk. Disk cleanup depends on your configured cleanup/expiration strategy.</p>\n</blockquote>\n<hr>\n<h2>List artifacts: <code>GET /data/files</code></h2>\n<p>Returns the list of known artifact ids (metadata-based) and their expiration information (if any). Expired entries are not returned.</p>\n<p>Example:</p>\n<pre><code class=\"language-bash hljs\"><span class=\"hljs-attribute\">curl</span> -s <span class=\"hljs-string\">\"http://&lt;slimfaas&gt;/data/files\"</span>\n</code></pre>\n<hr>\n<h2>Visibility &amp; security (Public vs Private)</h2>\n<p>All <code>/data/files</code> routes are protected by a <strong>data visibility</strong> setting.</p>\n<p>In <code>appsettings.json</code>:</p>\n<pre><code class=\"language-json hljs\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">\"Data\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">\"DefaultVisibility\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"Private\"</span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<h3>Behavior</h3>\n<ul>\n<li><strong>Public</strong>: anyone who can reach SlimFaas can call <code>/data/files</code></li>\n<li><strong>Private</strong> (recommended): only <strong>internal</strong> requests are allowed\nExternal requests are typically answered with <strong>404 Not Found</strong> (intentionally “hidden”).</li>\n</ul>\n<hr>\n<h2>Overriding visibility via environment variables</h2>\n<p>SlimFaas supports standard configuration overrides via environment variables.</p>\n<p>To override:</p>\n<ul>\n<li><code>Data:DefaultVisibility</code></li>\n</ul>\n<p>Use:</p>\n<ul>\n<li><code>Data__DefaultVisibility</code></li>\n</ul>\n<h3>Example: set <code>/data/files</code> to Public</h3>\n<h4>Docker / Docker Compose</h4>\n<pre><code class=\"language-bash hljs\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-attribute\">Data__DefaultVisibility</span>=Public\n</code></pre>\n<h4>Kubernetes Deployment (excerpt)</h4>\n<pre><code class=\"language-yaml hljs\"><span class=\"hljs-params\">env:</span>\n  <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Data__DefaultVisibility\n    <span class=\"hljs-params\">value:</span> <span class=\"hljs-string\">\"Public\"</span>\n</code></pre>\n<p>To keep it private (explicit):</p>\n<pre><code class=\"language-yaml hljs\"><span class=\"hljs-params\">env:</span>\n  <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Data__DefaultVisibility\n    <span class=\"hljs-params\">value:</span> <span class=\"hljs-string\">\"Private\"</span>\n</code></pre>\n<blockquote>\n<p>Notes</p>\n<ul>\n<li>This setting affects all data routes that are guarded by the same visibility filter, including <code>/data/files</code>.</li>\n<li>Use <code>Public</code> / <code>Private</code> for clarity.</li>\n</ul>\n</blockquote>\n<hr>\n<h2>How it works internally (high-level)</h2>\n<h3>1) Metadata is cluster-consistent; content is disk-backed</h3>\n<p>For <code>/data/files</code>:</p>\n<ul>\n<li><strong>metadata</strong> is stored in a cluster-consistent store so every node has the same view of what exists and how to serve it</li>\n<li><strong>binary content</strong> is stored on disk on the node that received the POST request</li>\n</ul>\n<p>This avoids moving large binaries through the cluster’s consensus layer.</p>\n<h3>2) Cluster distribution model: announce + pull</h3>\n<p>SlimFaas does not block the POST by pushing the binary to all nodes.</p>\n<p>Instead:</p>\n<ol>\n<li>The node that stored the artifact announces “I have <code>{id}</code> with checksum <code>{sha}</code>”</li>\n<li>Other nodes can <strong>pull</strong> the artifact in the background</li>\n<li>If a client requests an artifact from a node that doesn’t have it locally, that node can <strong>pull on demand</strong></li>\n</ol>\n<p>This yields eventual distribution with minimal upload latency.</p>\n<hr>\n<h2>The 256 MiB parallel limiter (safety guard)</h2>\n<p>SlimFaas applies a safety guard that limits concurrent binary transfers to roughly:</p>\n<ul>\n<li><strong>256 MiB in parallel</strong></li>\n</ul>\n<p>Meaning:</p>\n<ul>\n<li>each in-flight transfer reserves a “byte budget” equal to its size</li>\n<li>new transfers wait if starting them would exceed the budget</li>\n<li>a single artifact larger than 256 MiB can run only if it is <strong>alone</strong></li>\n</ul>\n<p><strong>This is not a strict memory cap</strong>; it’s a concurrency limiter.</p>\n<hr>\n<h2>Linux memory behavior (critical for sizing)</h2>\n<p>Even though SlimFaas streams uploads/downloads, <strong>Linux may cache file I/O in RAM</strong> (page cache). In containers, this commonly appears as:</p>\n<ul>\n<li>application memory looks stable,</li>\n<li>container memory usage grows (cgroup/RSS increases),</li>\n<li>memory may not drop immediately.</li>\n</ul>\n<h3>Practical consequence</h3>\n<p>With large artifacts (e.g., 200+ MB), you may see:</p>\n<ul>\n<li>a memory rise during storage (write → page cache),</li>\n<li>another rise when other nodes pull the artifact (read → page cache),</li>\n<li>slow return to baseline → risk of <strong>OOMKill</strong> if pod memory is too tight.</li>\n</ul>\n<h3>Sizing rule of thumb</h3>\n<p>Plan memory for:</p>\n<ul>\n<li>your baseline workload,</li>\n<li>\n<ul>\n<li>concurrent transfers (guarded by 256 MiB),</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>Linux page cache.</li>\n</ul>\n</li>\n</ul>\n<p>A safe starting point is often:</p>\n<ul>\n<li><strong>memory limit ≥ baseline + (2 × largest artifact size you expect to handle concurrently)</strong></li>\n</ul>\n<p>Tune based on real monitoring.</p>\n<hr>\n<h2>Storage &amp; durability</h2>\n<p><code>/data/files</code> is disk-backed:</p>\n<ul>\n<li>If storage is ephemeral, artifacts may disappear on pod restart.</li>\n<li>For durability, mount a persistent volume.</li>\n<li>Artifacts can be re-pulled from other nodes only while at least one node still has the content <strong>and</strong> metadata still exists.</li>\n</ul>\n<hr>\n<h2>Troubleshooting</h2>\n<h3>411 Length Required</h3>\n<p>Your client/proxy sent the request without <code>Content-Length</code> (often chunked transfer).\nFix: ensure uploads have a known length (e.g., <code>curl --data-binary @file</code>) and verify proxy settings.</p>\n<h3>404 Not Found on download</h3>\n<ul>\n<li>metadata expired or was deleted</li>\n<li>no node currently has the binary (restart, cleanup, ephemeral storage)</li>\n<li>temporary unavailability during cluster convergence</li>\n</ul>\n<h3>Memory grows and doesn’t drop</h3>\n<p>Usually Linux page cache behavior. Increase pod memory, reduce concurrency, or adapt storage strategy. Monitor cgroup/RSS and I/O.</p>\n<hr>\n<h2>Quick reference</h2>\n<ul>\n<li>Store: <code>POST /data/files?id={id?}&amp;ttl={ms?}</code></li>\n<li>Download: <code>GET /data/files/{id}</code></li>\n<li>Delete: <code>DELETE /data/files/{id}</code></li>\n<li>List: <code>GET /data/files</code></li>\n<li>Visibility config: <code>Data:DefaultVisibility = Public | Private</code></li>\n<li>Env override: <code>Data__DefaultVisibility=Public</code></li>\n</ul>\n</body></html>","metadata":{}},"__N_SSG":true}